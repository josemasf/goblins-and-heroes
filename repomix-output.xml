This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.editorconfig
.gitignore
AGENTS.md
DESIGN_RELIQUIAS.md
docs/spritesheet-guide.md
docs/update-coins-2.md
docs/update-enemies.md
docs/update-game-name.md
docs/update-player.md
env.d.ts
index.html
JUEGO_PLATAFORMAS.md
LICENSE
log.js
package.json
pnpm-workspace.yaml
public/style.css
README.md
src/App.vue
src/game/audio/Sfx.ts
src/game/boss/BossController.ts
src/game/core/Hero.ts
src/game/doors/DoorController.ts
src/game/EventBus.ts
src/game/main.ts
src/game/scenes/Boot.ts
src/game/scenes/CharacterSelect.ts
src/game/scenes/Game.ts
src/game/scenes/GameOver.ts
src/game/scenes/LevelSelectDev.ts
src/game/scenes/MainMenu.ts
src/game/scenes/Preloader.ts
src/game/spawners/CoinSpawner.ts
src/game/spawners/EnemySpawner.ts
src/game/spawners/PowerUpSpawner.ts
src/game/ui/Hud.ts
src/game/utils/PlatformUtils.ts
src/main.ts
src/PhaserGame.vue
src/vite-env.d.ts
tsconfig.json
tsconfig.node.json
vite/config.dev.mjs
vite/config.prod.mjs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".editorconfig">
# EditorConfig is awesome: https://EditorConfig.org

# top-most EditorConfig file
root = true

[*]
indent_style = space
indent_size = 4
end_of_line = crlf
charset = utf-8
trim_trailing_whitespace = false
insert_final_newline = false
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
.DS_Store
dist
dist-ssr
coverage
*.local

/cypress/videos/
/cypress/screenshots/

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

*.tsbuildinfo

.playwright-mcp
</file>

<file path="AGENTS.md">
# Repository Guidelines

## Project Structure & Module Organization
- `src/` ‚Äî Vue + TypeScript app code. Entry: `src/main.ts` and root `src/App.vue`.
- `src/game/` ‚Äî Phaser game code. Scenes in `src/game/scenes/` (e.g., `Game.ts`, `MainMenu.ts`), shared utilities like `EventBus.ts`, game entry `src/game/main.ts`.
- `public/` ‚Äî Static assets (images under `public/assets/`) and global styles (`public/style.css`).
- `vite/` ‚Äî Vite configs: `vite/config.dev.mjs` and `vite/config.prod.mjs`.
- Root ‚Äî `index.html`, configs, lockfiles.

## Build, Test, and Development Commands
- `npm install` ‚Äî Install dependencies (Node 18+ recommended).
- `npm run dev` ‚Äî Start Vite dev server on port 8080 (logs a build ping via `log.js`).
- `npm run dev-nolog` ‚Äî Start dev server without network logging.
- `npm run build` ‚Äî Production build using `vite/config.prod.mjs` (minified, vendor chunk for Phaser).
- `npm run build-nolog` ‚Äî Production build without network logging.
- `npm run typecheck` ‚Äî Static type check via `vue-tsc`.
- You may use `pnpm` if preferred (a `pnpm-lock.yaml` exists): e.g., `pnpm dev`.

## Coding Style & Naming Conventions
- TypeScript: strict mode enabled in `tsconfig.json` ‚Äî fix `noUnused*` and related errors.
- Indentation: 2 spaces; semicolons required; single quotes preferred in TS.
- Vue SFCs: PascalCase filenames (e.g., `PhaserGame.vue`), `<script setup lang="ts">` when possible.
- Phaser scenes and classes: PascalCase filenames and class names (one class per file).
- Imports: prefer `@/...` alias for paths under `src/`.

## Testing Guidelines
- No automated test runner currently. Validate changes by:
  - Running the dev server and exercising scenes and UI.
  - Running `npx vue-tsc --noEmit` for static checks.
  - Optional: add lightweight unit tests before large refactors.

## Commit & Pull Request Guidelines
- Commits: use meaningful messages. Conventional Commits are encouraged: `feat:`, `fix:`, `chore:`, `docs:`.
- PRs: include a clear summary, steps to run/verify, screenshots or GIFs of gameplay, and link issues.
- Assets: include only licensed media in `public/assets/` and credit as needed.

## Security & Configuration Tips
- `log.js` makes an external HTTPS request during `dev`/`build`. Use `*-nolog` scripts if offline or avoiding telemetry.
- Do not commit secrets. Prefer environment-driven config via Vite when needed.
 - Recommended Node: 18 or newer (`"engines": { "node": ">=18" }`).
</file>

<file path="DESIGN_RELIQUIAS.md">
# Dise√±o: Reliquias, Equipamiento y Progresi√≥n

## Objetivo
- A√±adir exploraci√≥n con recompensa, progresi√≥n del h√©roe y profundidad estrat√©gica.
- Integraci√≥n modular y por fases, compatible con la arquitectura Phaser + Vue actual.

## Modelo de Datos
- `player.relics: Relic[]` ‚Äî reliquias obtenidas durante la partida (persisten entre niveles).
- `player.equipment: EquipmentSlots` ‚Äî equipo visible (casco, armadura, arma, escudo).
- `player.stats: Stats` ‚Äî estad√≠sticas derivadas (velocidad, salto, defensa, etc.).

Tipos sugeridos (TypeScript, referencia):

```
export type Rarity = 'Com√∫n' | 'Raro' | '√âpico' | 'Legendario';

export interface Relic {
  id: string;           // p.ej. 'amulet_vigor'
  name: string;         // 'Amuleto de Vigor'
  rarity: Rarity;
  type: 'passive' | 'active';
  iconKey?: string;     // key en atlas/spritesheet si aplica
  cooldown?: number;    // ms (solo active)
  duration?: number;    // ms (si aplica efecto temporal)
  lastUsedAt?: number;  // timestamp ms (gesti√≥n cooldown)
  stacks?: number;      // acumulaciones si corresponde
  state?: any;          // almacenamiento ligero para l√≥gica concreta
}

export interface EquipmentSlots {
  head?: string;   // id casco
  armor?: string;  // id armadura
  weapon?: string; // id arma
  shield?: string; // id escudo
}

export interface Stats {
  speedX: number;
  jumpV: number;
  maxLives: number;
  defensePct: number; // 0..1
}
```

## Serializaci√≥n y Persistencia
- Entre escenas: usar `this.registry` (Phaser) para compartir `player.relics`, `player.equipment`, `player.stats`.
  - Claves recomendadas: `relics`, `equipment`, `stats`.
  - Guardar como objetos directos (Phaser Registry soporta referencias), o como JSON si se prefiere `JSON.stringify`/`parse`.
- Entre niveles (ya implementado path/level): asegurar que en `Game.create()` se lea de `registry` y se apliquen efectos.
- Entre partidas (meta‚Äëprogresi√≥n opcional): `localStorage` con versi√≥n: `gnh_meta_v1`.

## Hooks de Integraci√≥n
- `onSceneCreate(Game)`
  - Leer `relics` y recalcular `player.stats` (aplicar pasivas).
  - Configurar inputs extra (disparo, sigilo) si hay reliquias activas.
- `onCollectRelic(relic: Relic)`
  - A√±adir a `player.relics`, aplicar efecto inmediato si procede y mostrar UI (toast + icono HUD).
- `onUpdate(time, delta)`
  - Gestionar cooldowns de reliquias activas (HUD con barra/contador).
- Eventos del juego como disparadores:
  - `onCoinCollected`, `onEnemyKilled`, `onDamaged`, `onPowerUpTaken`, `onJump`.
  - Permiten reliquias que reaccionen (bonus de velocidad, negaci√≥n de golpe, curaci√≥n, etc.).

## Reliquias de Ejemplo (MVP)
1) Amuleto de Vigor (Com√∫n, passive)
- Efecto: +1 salto extra.
- L√≥gica: contador `extraJumpCharges = 1` que se resetea al tocar suelo; en `update()`, si salto y `!touching.down` y `charges>0`, permitir salto y `charges--`.
- HUD: icono pasivo.

2) Cr√°neo R√∫nico (Raro, active)
- Efecto: ataque m√°gico cargado.
- Input: mantener `J` para cargar (hasta 1.2s), soltar para disparar proyectil; da√±o/velocidad escalan con carga.
- Cooldown: 6s desde el disparo.
- HUD: icono con cooldown.

3) Gema de la Sombra (√âpico, active)
- Efecto: invisibilidad 5s (ignora colisiones con enemigos, opacidad 0.5, no invulnerable a ca√≠das).
- Cooldown: 12s.
- HUD: temporizador de duraci√≥n y cooldown.

4) Corona del Rey Goblin (Legendario, active)
- Efecto: goblins neutrales 8s (no atacan; desactivar overlaps de da√±o o cambiar grupo temporalmente).
- Cooldown: 30s.
- HUD: icono con barra de duraci√≥n.

## Sistema de Armas y Armaduras
- `equipment.weapon` cambia animaciones y ataques (espada/ballesta/lanza).
- `equipment.head/armor/shield` ajustan defensa y sprite del h√©roe (capas).
- Hook: al equipar, actualizar grupo de sprites (capa casco/torso/brazo/arma) y `stats`.

## HUD / UI
- Overlay de reliquias: fila de iconos con rareza (marco color) y estado (activo/cooldown).
- Inventario simple (Fase 1): lista vertical con tooltip.
- Indicadores en juego: texto flotante al recoger + sonido.

## Enemigos Tem√°ticos (resumen t√©cnico)
- `goblin_guard`: m√°s vida/da√±o, anclado a un cofre; al morir, desbloquea cofre.
- `goblin_shaman`: AI con proyectiles y sum√≥n; prioridad de objetivos.
- `goblin_elite`: con equipo al azar (drop de slot al morir).
- `hatchery` (nido): spawnea minions con l√≠mite y cooldown.

## Fases de Implementaci√≥n
Fase 1 (reliquias funcionales)
- [ ] A√±adir entidad Cofre con tabla de loot (Com√∫n/Raro/√âpico/Legendario).
- [ ] Guardar `player.relics` en `registry` y aplicarlas al crear escena.
- [ ] Implementar Amuleto de Vigor, Cr√°neo R√∫nico, Gema de la Sombra, Corona del Rey Goblin.
- [ ] HUD b√°sico de reliquias (icono + cooldown/duraci√≥n).

Fase 2 (equipamiento visible)
- [ ] Dividir sprite del h√©roe en capas (cabeza/torso/brazos/casco/arma/escudo).
- [ ] Implementar 3 armas iniciales (espada, ballesta, lanza) y sus animaciones.

Fase 3 (enemigos y secretos)
- [ ] Nuevos goblins (guardia, cham√°n, √©lite) + nido de cr√≠as.
- [ ] Cofres protegidos; llaves y puertas selladas; salas secretas.

## Persistencia y Limpieza
- En `Game.create()`:
  - `const relics = this.registry.get('relics') as Relic[] || []`.
  - Aplicar pasivas y configurar inputs.
- Al cambiar de nivel (puertas): mantener `relics` en `registry`.
- Al volver al selector: resetear progreso (opcional), conservar meta‚Äëprogresi√≥n en `localStorage`.

## Consideraciones
- Evitar efectos que bloqueen input; usar `JustDown`/`JustUp` para activos.
- Priorizar rendimiento: proyectiles y efectos reutilizando grupos.
- Balancear n√∫meros con constantes (`RELICS_CONFIG`) y facilitar tuning.

```
export const RELICS_CONFIG = {
  skull_rune: { cooldown: 6000, maxChargeMs: 1200 },
  shadow_gem: { cooldown: 12000, duration: 5000 },
  goblin_crown: { cooldown: 30000, duration: 8000 },
};
```

## Pr√≥ximos Pasos Recomendados
- Implementar Fase 1 (cofres + 4 reliquias) con HUD b√°sico.
- A√±adir sonidos/part√≠culas espec√≠ficos por reliquia.
- Guardar/leer `relics` y `equipment` en `registry` y probar paso entre niveles.
</file>

<file path="docs/spritesheet-guide.md">
# Gu√≠a de Spritesheets para el Juego

## üìê Dimensiones requeridas

### Formato ideal para pixel art (24√ó24 por frame)

#### Monedas
- **Archivo**: `coin_sheet.png`
- **Dimensiones totales**: 192√ó48 p√≠xeles (o 384√ó96 para doble resoluci√≥n)
- **Grid**: 8 frames horizontales √ó 1 fila
- **Frame size**: 24√ó24 p√≠xeles (o 48√ó48)
- **Total frames**: 8 frames para animaci√≥n de giro

#### Power-ups (vida, velocidad, invencibilidad)
- **Archivos**: `pu_life_sheet.png`, `pu_speed_sheet.png`, `pu_inv_sheet.png`
- **Dimensiones totales**: 192√ó48 p√≠xeles (o 384√ó96)
- **Grid**: 8 frames horizontales √ó 1 fila
- **Frame size**: 24√ó24 p√≠xeles (o 48√ó48)
- **Total frames**: 8 frames para animaci√≥n idle/pulso

## üõ†Ô∏è C√≥mo crear los spritesheets

### Opci√≥n 1: Piskel (Recomendado - Gratis, Online)
1. Ve a https://www.piskelapp.com/
2. Create Sprite ‚Üí Set frame size: 24√ó24
3. Dibuja tu sprite en cada frame
4. Export ‚Üí Download PNG (sprite sheet)
5. Aseg√∫rate de exportar como 1 fila √ó 8 columnas

### Opci√≥n 2: Aseprite (De pago, profesional)
1. New Sprite ‚Üí 24√ó24 pixels
2. Crea 8 frames
3. File ‚Üí Export Sprite Sheet
4. Layout: Horizontal strip (1 row)
5. Export

### Opci√≥n 3: Redimensionar existentes con ImageMagick
```powershell
# Instalar: https://imagemagick.org/
cd public/assets

# Redimensionar manteniendo pixel art (sin blur)
magick coin_sheet.png -sample 192x48! coin_sheet_new.png
magick pu_life_sheet.png -sample 192x48! pu_life_new.png
magick pu_speed_sheet.png -sample 192x48! pu_speed_new.png
magick pu_inv_sheet.png -sample 192x48! pu_inv_new.png

# Reemplazar archivos originales
mv coin_sheet_new.png coin_sheet.png
mv pu_life_new.png pu_life_sheet.png
mv pu_speed_new.png pu_speed_sheet.png
mv pu_inv_new.png pu_inv_sheet.png
```

## üìù Actualizar c√≥digo despu√©s de cambiar im√°genes

Si cambias las im√°genes a 192√ó48 (8 frames de 24√ó24), actualiza `Preloader.ts`:

```typescript
// En preload():
this.load.spritesheet('coin_sheet', 'coin_sheet.png', { 
    frameWidth: 24, 
    frameHeight: 24 
});
this.load.spritesheet('pu_life_sheet', 'pu_life_sheet.png', { 
    frameWidth: 24, 
    frameHeight: 24 
});
this.load.spritesheet('pu_speed_sheet', 'pu_speed_sheet.png', { 
    frameWidth: 24, 
    frameHeight: 24 
});
this.load.spritesheet('pu_inv_sheet', 'pu_inv_sheet.png', { 
    frameWidth: 24, 
    frameHeight: 24 
});

// En create(), las animaciones usar√°n 0-7 (8 frames) en lugar de 0-15:
this.anims.create({ 
    key: 'coin_spin', 
    frames: this.anims.generateFrameNumbers('coin_sheet', { start: 0, end: 7 }), 
    frameRate: 14, 
    repeat: -1 
});
```

Y en `Game.ts`, puedes **ELIMINAR** el `setScale(0.125)` porque ya estar√°n al tama√±o correcto.

## ‚úÖ Checklist

- [ ] Spritesheets tienen exactamente 8 frames cada uno
- [ ] Cada frame es 24√ó24 p√≠xeles (o 48√ó48 para 2x)
- [ ] Formato PNG con transparencia
- [ ] Sin espaciado entre frames
- [ ] Organizados en 1 fila horizontal
- [ ] Nombres de archivo coinciden exactamente: `coin_sheet.png`, `pu_life_sheet.png`, etc.
</file>

<file path="docs/update-coins-2.md">
Vale: si las monedas y los power-ups ‚Äúno se ven bien‚Äù, el problema suele ser **filtro bilineal, sub-p√≠xeles y/o escalado por CSS**. Te dejo un **plan de ejecuci√≥n** brutalmente concreto para que en Phaser se vean **n√≠tidos, pixel perfect y animados**.

---

# Plan de acci√≥n (apl√≠calo tal cual)

## 1) Phaser config: pixel art sin suavizado

En `src/game/main.ts` ya usas `pixelArt: true`. A√±ade `render.antialias = false` para forzar el ‚Äúnearest‚Äù del canvas y evitar blur. 

```ts
const config: Phaser.Types.Core.GameConfig = {
  // ...
  pixelArt: true,
  render: { antialias: false }, // <‚Äî a√±ade esto
  physics: { /* ... */ },
  scene: [/* ... */]
};
```

## 2) Canvas CSS: que el navegador no borre el pixel

Ajusta `public/style.css` para el lienzo (canvas) dentro de `#game-container`. Esto evita el suavizado si el canvas se escala por CSS. 

```css
#game-container canvas {
  image-rendering: pixelated;
  image-rendering: crisp-edges; /* fallback */
}
```

## 3) C√°mara: p√≠xel redondeado

En `Game.ts` ya activaste `roundPixels` en la c√°mara. Mant√©n eso (clave para que los tweens no metan sub-p√≠xeles). 

```ts
this.camera = this.cameras.main;
this.camera.roundPixels = true;
```

## 4) Asegura filtro NEAREST en las texturas cargadas

En `Preloader.ts`, tras crear animaciones (en `create()`), fuerza el filtro por textura (Phaser 3.60+). 

```ts
['coin_sheet','pu_life_sheet','pu_speed_sheet','pu_inv_sheet'].forEach(k => {
  this.textures.get(k).setFilter(Phaser.Textures.FilterMode.NEAREST);
});
```

## 5) Animaciones: ya definidas, mantenlas

Tienes las anims correctas (`coin_spin` y `pu_*_idle`). D√©jalas igual (o 12‚Äì14 fps si quieres suavidad). 

## 6) Instanciaci√≥n correcta (Sprite + hitbox + bob)

Aseg√∫rate de que **NO** usas `Image` ni `setDisplaySize` con estos assets (eso reescala y emborrona). Usa `Sprite`, `play(anim)`, hitbox compacto y tween que no meta escalas fraccionarias.

### Monedas ‚Äî `Game.ts` (en `createCoins()`)

```ts
const coin = this.coins.create(x, y, 'coin_sheet', 0) as Phaser.Physics.Arcade.Sprite;
coin.play('coin_spin');
coin.body.setSize(16, 16).setOffset(4, 4); // hitbox centrada
this.tweens.add({
  targets: coin,
  y: coin.y - 4,
  duration: 800,
  yoyo: true,
  repeat: -1,
  ease: 'Sine.inOut'
});
```

> Nada de `setDisplaySize`. Si quieres ‚Äúhacerlas grandes‚Äù, usa `coin.setScale(2)` (enteros, siempre). 

### Power-ups ‚Äî `Game.ts` (en `createPowerUps()`)

```ts
const pu = this.powerUps.create(x, y, 'pu_speed_sheet', 0) as Phaser.Physics.Arcade.Sprite;
pu.play('pu_speed_idle');
pu.setBlendMode(Phaser.BlendModes.ADD);    // brillo sin blur
pu.body.setSize(16, 16).setOffset(4, 4);
this.tweens.add({
  targets: pu,
  y: pu.y - 4,
  duration: 900,
  yoyo: true,
  repeat: -1,
  ease: 'Sine.inOut'
});
```

> Evita `setDisplaySize`. `setScale(2)` si necesitas, pero **enteros**. Y con `roundPixels` activo no habr√° ‚Äúbailes‚Äù sub-p√≠xel. 

## 7) Carga de hojas: OK como spritesheet 24√ó24

Tu `Preloader.ts` ya carga 24√ó24 y crea anims. No generes versiones procedurales de monedas/power-ups (ya est√°n como no-op). 

```ts
this.load.spritesheet('coin_sheet','coin_sheet.png',{ frameWidth:24, frameHeight:24 });
this.load.spritesheet('pu_life_sheet','pu_life_sheet.png',{ frameWidth:24, frameHeight:24 });
this.load.spritesheet('pu_speed_sheet','pu_speed_sheet.png',{ frameWidth:24, frameHeight:24 });
this.load.spritesheet('pu_inv_sheet','pu_inv_sheet.png',{ frameWidth:24, frameHeight:24 });
// ...
// Animaciones (ya en tu repo):
// 'coin_spin' y 'pu_*_idle'
```

---

# Checklist de verificaci√≥n (2 minutos)

1. **Canvas n√≠tido**: inspecciona el `<canvas>` y confirma que tiene `image-rendering: pixelated` aplicado. 
2. **Sin `setDisplaySize`** en monedas/power-ups; si ves blur, busca y elimina ese m√©todo. Usa `setScale(2)` entero si hace falta.
3. **Anim corriendo**: monedas con `coin_spin` (12‚Äì14 fps), power-ups con `pu_*_idle` (8‚Äì12 fps). 
4. **C√°mara**: `roundPixels = true` (ya lo tienes). 
5. **Filtro NEAREST** forzado en runtime para las hojas (paso 4). 

---

# ¬øPor qu√© pasaba?

* El **blur** ven√≠a del **antialias del canvas** y/o de **escalado CSS** del canvas; tambi√©n de sub-p√≠xeles al tweenear. Con `pixelArt: true`, `antialias: false`, `image-rendering: pixelated` y `roundPixels`, desaparece.   

---

Si quieres, te genero un **parche `.diff`** con:

* cambio en `main.ts` (antialias),
* CSS `image-rendering: pixelated`,
* y snippet `setFilter(NEAREST)` en `Preloader.ts`.
</file>

<file path="docs/update-enemies.md">
# Integraci√≥n en tu proyecto (quir√∫rgica y sin dramas)

Tu proyecto hoy crea enemigos con la textura `'enemy'` (c√≠rculo) y el jefe con `'boss'` (c√≠rculo grande), y dispara proyectiles `'projectile'`. Vamos a sustituirlos por las hojas y reproducir animaciones sin romper tu IA ni la l√≥gica de timers.  

## 1) Mueve los PNG

Pon los 3 archivos en `public/assets/`. El loader ya hace `this.load.setPath('assets')` en `Preloader`. 

## 2) `Preloader.ts`

### a) Carga nuevas hojas (en `preload()`)

```ts
this.load.spritesheet('goblin_green_sheet', 'assets/goblin_green_sheet.png', { frameWidth: 32, frameHeight: 32 });
this.load.spritesheet('goblin_red_sheet',   'assets/goblin_red_sheet.png',   { frameWidth: 32, frameHeight: 32 });
this.load.spritesheet('boss_troll_sheet',   'assets/boss_troll_sheet.png',   { frameWidth: 64, frameHeight: 64 });
```

### b) Crea animaciones (en `create()`)

```ts
// Duendes (comparten claves con prefijo para no colisionar)
this.anims.create({ key:'goblin_idle', frames: this.anims.generateFrameNumbers('goblin_green_sheet',{start:0,end:3}), frameRate:6, repeat:-1 });
this.anims.create({ key:'goblin_run',  frames: this.anims.generateFrameNumbers('goblin_green_sheet',{start:4,end:9}), frameRate:10, repeat:-1 });
this.anims.create({ key:'goblin_atk',  frames: this.anims.generateFrameNumbers('goblin_green_sheet',{start:10,end:12}), frameRate:8, repeat:0  });
this.anims.create({ key:'goblin_hit',  frames: this.anims.generateFrameNumbers('goblin_green_sheet',{start:13,end:16}), frameRate:10, repeat:0  });

// Variante roja reusa las mismas keys via 'sheet' alterno cuando la creemos

// Jefe Trol
this.anims.create({ key:'troll_idle',   frames: this.anims.generateFrameNumbers('boss_troll_sheet',{start:0,end:3}),  frameRate:5,  repeat:-1 });
this.anims.create({ key:'troll_run',    frames: this.anims.generateFrameNumbers('boss_troll_sheet',{start:4,end:9}),  frameRate:8,  repeat:-1 });
this.anims.create({ key:'troll_cast',   frames: this.anims.generateFrameNumbers('boss_troll_sheet',{start:10,end:12}), frameRate:8,  repeat:0  });
this.anims.create({ key:'troll_portal', frames: this.anims.generateFrameNumbers('boss_troll_sheet',{start:13,end:16}), frameRate:10, repeat:0  });
```

> Ojo: mantenemos tus cargas existentes (plataformas, monedas, projectile, puertas, etc.). 

---

## 3) `Game.ts` ‚Äî Enemigos (duendes)

Hoy instancias enemigos con `this.enemies.create(pos.x, pos.y, 'enemy')` y los haces rebotar con velocidad horizontal random. Vamos a usar **Sprite** con sheet y anim **run**, m√°s flip por direcci√≥n.  

```ts
createEnemies() {
  this.enemies = this.physics.add.group();

  // ... tu l√≥gica de posiciones se queda igual

  enemyPositions.forEach((pos, idx) => {
    // Alterna verde/rojo para variedad
    const key = (idx % 2 === 0) ? 'goblin_green_sheet' : 'goblin_red_sheet';
    const gob = this.enemies.create(pos.x, pos.y, key, 0) as Phaser.Physics.Arcade.Sprite;

    gob.setBounce(1).setCollideWorldBounds(true);
    gob.setVelocity(Phaser.Math.Between(-200, 200), 0);

    // Caja un pel√≠n m√°s estrecha que el 32x32
    gob.body.setSize(20, 26).setOffset(6, 6);

    gob.play('goblin_run');
  });
}
```

En tu `update()` a√±ade esto para el **flip** de los duendes seg√∫n direcci√≥n (no cambia IA, solo est√©tica):

```ts
this.enemies.children.iterate((e: any) => {
  const s = e as Phaser.Physics.Arcade.Sprite;
  if (s.body) s.setFlipX((s.body as any).velocity.x < 0);
});
```

> Si quieres que, al colisionar con el jugador, el duende haga un ‚Äúhit‚Äù, puedes disparar `goblin_hit` en tu `hitEnemy()`, pero ahora mismo esa funci√≥n est√° centrada en feedback al jugador, no al enemigo. Lo dejo como opcional para no tocar tu gameplay. 

---

## 4) `Game.ts` ‚Äî Jefe (trol)

Tu `spawnBoss()` crea un `image` con clave `'boss'` y usa timers para **disparo** y **teletransporte**. Vamos a:

* Usar **Sprite** desde la hoja y reproducir animaciones.
* En `shootTimer`, reproducir `troll_cast` antes del proyectil.
* En `teleportTimer`, reproducir `troll_portal` y luego mover.

C√≥digo drop-in (sustituye el m√©todo entero):  

```ts
private spawnBoss() {
  const boss = this.physics.add.sprite(700, 300, 'boss_troll_sheet', 0);
  this.boss = boss as any;
  boss.setImmovable(true).setCollideWorldBounds(true);
  this.physics.add.collider(boss, this.platforms);
  this.physics.add.overlap(this.player, boss, this.hitEnemy, undefined, this);
  boss.play('troll_idle');

  this.projectiles = this.physics.add.group();

  // Disparo cada 1.5s con anim de casteo
  this.shootTimer = this.time.addEvent({
    delay: 1500, loop: true, callback: () => {
      if (!this.boss) return;
      boss.play('troll_cast');
      // Lanza el proyectil cuando termina el cast
      boss.once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
        if (!this.boss) return;
        const proj = this.projectiles!.create(boss.x, boss.y, 'projectile') as Phaser.Physics.Arcade.Image;
        const angle = Phaser.Math.Angle.Between(boss.x, boss.y, this.player.x, this.player.y);
        const speed = 220;
        proj.setVelocity(Math.cos(angle) * speed, Math.sin(angle) * speed);
        boss.play('troll_idle'); // vuelta a idle
      });
    }
  });

  // Teletransporte cada 4s con anim portal
  this.teleportTimer = this.time.addEvent({
    delay: 4000, loop: true, callback: () => {
      if (!this.boss) return;
      boss.play('troll_portal');
      boss.once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
        if (!this.boss) return;
        const spots = [ {x: 250, y: 300}, {x: 750, y: 260}, {x: 500, y: 200} ];
        const s = Phaser.Utils.Array.GetRandom(spots);
        boss.setPosition(s.x, s.y);
        this.cameras.main.flash(150, 255, 255, 255);
        boss.play('troll_idle');
      });
    }
  });
}
```

> Mantengo tu **projectile** morado y colisiones existentes en `setupPhysics()`, que ya se encargan de overlap con el jugador y collider con plataformas. 

---

# Plan de acci√≥n (para Codex)

1. **Copiar assets**

   * A√±adir `goblin_green_sheet.png`, `goblin_red_sheet.png`, `boss_troll_sheet.png` a `public/assets/`.

2. **Preloader.ts**

   * Agregar `load.spritesheet` para los 3 nuevos assets.
   * Crear anims:

     * Duende: `goblin_idle`, `goblin_run`, `goblin_atk`, `goblin_hit`.
     * Trol: `troll_idle`, `troll_run`, `troll_cast`, `troll_portal`.

3. **Game.ts**

   * En `createEnemies()`, cambiar textura `'enemy'` por hoja `goblin_*_sheet`, reproducir `goblin_run`, ajustar `body.setSize(20,26)`.
   * En `update()`, a√±adir flip horizontal de duendes seg√∫n velocidad X.
   * Reemplazar `spawnBoss()` para usar sprite `boss_troll_sheet` con animaciones (`troll_idle/cast/portal`), y gatillar cast/teleport en los timers antes de crear proyectil o mover.

4. **(Opcional)** Ajustes finos

   * `goblin_run` a 12 fps si quieres m√°s nervio.
   * `troll_run` si decides moverlo; si el trol es est√°tico, mant√©n `idle`.
   * `projectile` puede heredar un brillo si le aplicas `setBlendMode(Phaser.BlendModes.ADD)`.

5. **Probar**

   * `pnpm dev` ‚Üí revisa: duendes caminando con flip correcto; trol casteando antes de disparar; efecto portal antes de teletransportarse.
   * Validar que `setupPhysics()` sigue colisionando proyectiles y plataformas como antes. 

6. **Commit**

   * `feat(art): goblins & troll spritesheets + boss anim flow`.

---

¬øQuieres que tambi√©n te deje un **parche .diff** con las modificaciones exactas en `Preloader.ts` y `Game.ts` para aplicarlo del tir√≥n?
</file>

<file path="docs/update-game-name.md">
Perfecto. Aqu√≠ tienes un **plan de ejecuci√≥n claro y corto** para renombrar el proyecto a **Goblins & Heroes** sin romper nada.

---

# Plan ‚ÄúGoblins & Heroes‚Äù

## 0) Rama y checklist

```bash
git checkout -b feat/rename-goblins-and-heroes
```

Checklist de salida:

* T√≠tulo en HTML actualizado
* T√≠tulo en men√∫ del juego actualizado
* Favicon OK (opcional con la moneda)
* `package.json` con nuevo `name` y `description`
* Docs (`README`, `JUEGO_PLATAFORMAS.md`) actualizados
* Build local OK

---

## 1) Cambiar t√≠tulo del HTML

Edita `index.html` y cambia el `<title>` actual (‚ÄúPhaser Vue Template‚Äù) por el nuevo nombre. 

```html
<title>Goblins & Heroes</title>
```

---

## 2) T√≠tulo visible dentro del juego (Men√∫ Principal)

En `src/game/scenes/MainMenu.ts`, ahora muestras **"Aventura de Plataformas"** con un `add.text`. Cambia ese string a **Goblins & Heroes**. 

```ts
this.title = this.add.text(512, 350, 'Goblins & Heroes', {
  fontFamily: 'Arial Black', fontSize: 48, color: '#ffffff',
  stroke: '#000000', strokeThickness: 8, align: 'center'
}).setOrigin(0.5).setDepth(100);
```

---

## 2.b) Imagen de en intro

La imagen de public/assets/intro.png la quiero en la portada del juego

---

## 3) (Opcional pero recomendable) Favicon con la moneda

Usa el frame 0 de `coin_sheet.png` para generar el favicon al vuelo desde el `Preloader`. El `Preloader` ya carga assets con `this.load.setPath('assets')` y genera objetos; a√±ade este bloque tras el `COMPLETE` del loader. 

```ts
this.load.once(Phaser.Loader.Events.COMPLETE, () => {
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = 32;
  const ctx = canvas.getContext('2d')!;
  const coin = this.textures.get('coin_sheet').getSourceImage() as HTMLImageElement;
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(coin, 0, 0, 24, 24, 4, 4, 24, 24);

  let link = document.querySelector('link[rel="icon"]') as HTMLLinkElement;
  if (!link) { link = document.createElement('link'); link.rel = 'icon'; link.type = 'image/png'; document.head.appendChild(link); }
  link.href = canvas.toDataURL('image/png');
});
```

---

## 4) `package.json`

Actualiza nombre y descripci√≥n del paquete para que refleje el juego (y sea instalable sin colisiones). 

```json
{
  "name": "goblins-and-heroes",
  "description": "Goblins & Heroes ‚Äî juego de plataformas 2D en Phaser + Vue + TypeScript",
  ...
}
```

---

## 5) Documentaci√≥n

* Renombra cabecera y menciones en `JUEGO_PLATAFORMAS.md` (encabezado y la primera frase). 

  * `# üéÆ Goblins & Heroes`
  * ‚ÄúUn emocionante juego‚Ä¶‚Äù ‚Üí ‚Äú**Goblins & Heroes** es un juego‚Ä¶‚Äù
* Si incluyes un README de producto (aparte del de la plantilla), aj√∫stalo; el actual es el de la plantilla de Phaser, puedes a√±adir un bloque inicial con el nombre. 

---

## 6) Build y prueba

```bash
pnpm install
pnpm dev
# comprobar: t√≠tulo de la pesta√±a, men√∫ principal mostrando "Goblins & Heroes", favicon (si hiciste el paso 3)
pnpm build
```

---

## 7) Commit at√≥mico y PR

```bash
git add .
git commit -m "feat: rename project to Goblins & Heroes (title, menu, pkg, docs)"
git push -u origin feat/rename-goblins-and-heroes
# Abre PR y auto-merge tras aprobar
```

---

## 8) (Opcional) Toques de calidad

* **HUD / Game Over**: si quieres, a√±ade ‚ÄúGoblins & Heroes‚Äù en la pantalla final encima de ‚ÄúFin del Juego‚Äù en `GameOver.ts`. 
* **Metadatos sociales**: a√±ade en `index.html` meta og:title / description para tarjetas de enlace con el nuevo nombre. 
* **Tagline**: en `MainMenu.ts` puedes a√±adir un subt√≠tulo peque√±o bajo el t√≠tulo (p. ej. *‚ÄúElige tu h√©roe. Domina a los goblins.‚Äù*). 

---

### Resultado esperado

* T√≠tulo del navegador: **Goblins & Heroes** (HTML) 
* T√≠tulo in-game: **Goblins & Heroes** (Men√∫) 
* `package.json` con nuevo nombre visible en builds / lockfiles 
* Docs con el nuevo branding 

¬øQuieres que te genere un **parche `.diff`** listo para aplicar con todos estos cambios de una?
</file>

<file path="docs/update-player.md">
# Plan de acci√≥n (para correr en Codex / agente)

Objetivo: integrar las hojas y dejar todo animado con **idle, run, jump, pick**, sin romper tu l√≥gica actual.

## 1) Assets

* Copia los 3 PNG a `public/assets/` (o tu carpeta `assets` servida). Tu preloader ya usa `this.load.setPath('assets')`. 

## 2) `Preloader.ts`

**a) Desactiva sprites procedurales de h√©roes**

* En `createHeroSprites()`, elimina o comenta la generaci√≥n con `this.add.graphics().generateTexture(...)`. (As√≠ evitas texturas `hero_*_1`, `hero_*_2`, etc.). 

**b) Carga spritesheets en `preload()`**

```ts
this.load.spritesheet('hero_speed_sheet', 'assets/hero_speed_sheet.png', { frameWidth: 32, frameHeight: 32 });
this.load.spritesheet('hero_jump_sheet',  'assets/hero_jump_sheet.png',  { frameWidth: 32, frameHeight: 32 });
this.load.spritesheet('hero_tank_sheet',  'assets/hero_tank_sheet.png',  { frameWidth: 32, frameHeight: 32 });
```

**c) Crea animaciones en `create()`** (reemplaza las `walk_*` que ya ten√≠as por √©stas‚Äîmantengo nombres `walk_*` para compatibilidad con tu `Game.ts`). 

```ts
// SPEED
this.anims.create({ key:'idle_speed', frames: this.anims.generateFrameNumbers('hero_speed_sheet',{start:0,end:3}), frameRate:6,  repeat:-1 });
this.anims.create({ key:'walk_speed', frames: this.anims.generateFrameNumbers('hero_speed_sheet',{start:4,end:9}), frameRate:12, repeat:-1 });
this.anims.create({ key:'jump_speed', frames: this.anims.generateFrameNumbers('hero_speed_sheet',{start:10,end:12}), frameRate:8,  repeat:0  });
this.anims.create({ key:'pick_speed', frames: this.anims.generateFrameNumbers('hero_speed_sheet',{start:13,end:16}), frameRate:10, repeat:0  });

// JUMP
this.anims.create({ key:'idle_jump',  frames: this.anims.generateFrameNumbers('hero_jump_sheet',{start:0,end:3}),  frameRate:6,  repeat:-1 });
this.anims.create({ key:'walk_jump',  frames: this.anims.generateFrameNumbers('hero_jump_sheet',{start:4,end:9}),  frameRate:12, repeat:-1 });
this.anims.create({ key:'jump_jump',  frames: this.anims.generateFrameNumbers('hero_jump_sheet',{start:10,end:12}), frameRate:8,  repeat:0  });
this.anims.create({ key:'pick_jump',  frames: this.anims.generateFrameNumbers('hero_jump_sheet',{start:13,end:16}), frameRate:10, repeat:0  });

// TANK
this.anims.create({ key:'idle_tank',  frames: this.anims.generateFrameNumbers('hero_tank_sheet',{start:0,end:3}),  frameRate:5,  repeat:-1 });
this.anims.create({ key:'walk_tank',  frames: this.anims.generateFrameNumbers('hero_tank_sheet',{start:4,end:9}),  frameRate:10, repeat:-1 });
this.anims.create({ key:'jump_tank',  frames: this.anims.generateFrameNumbers('hero_tank_sheet',{start:10,end:12}), frameRate:6,  repeat:0  });
this.anims.create({ key:'pick_tank',  frames: this.anims.generateFrameNumbers('hero_tank_sheet',{start:13,end:16}), frameRate:8,  repeat:0  });
```

## 3) `Game.ts`

**a) Crear el jugador desde la hoja**
Sustituye el uso de texturas sueltas (`hero_speed_1`, etc.) por la hoja + frame 0: 

```ts
private sheetKeyFromHero(key: string): string {
  if (key === 'hero_speed') return 'hero_speed_sheet';
  if (key === 'hero_tank')  return 'hero_tank_sheet';
  return 'hero_jump_sheet';
}

createPlayer() {
  const sheet = this.sheetKeyFromHero(this.heroKey);
  this.player = this.physics.add.sprite(100, 700, sheet, 0);
  this.player.setBounce(0.2).setCollideWorldBounds(true).setScale(1);
}
```

**b) Update: usar anims para aire/caminar/idle**
Reemplaza el bloque que usa `setTexture(this.jumpFrameFromHero(...))` por animaciones:

```ts
const onGround = this.player.body!.touching.down;
const vx = this.player.body!.velocity.x;
const moving = Math.abs(vx) > 10 && onGround;

const isSpeed = this.heroKey === 'hero_speed';
const isTank  = this.heroKey === 'hero_tank';
const walkKey = isSpeed ? 'walk_speed' : isTank ? 'walk_tank' : 'walk_jump';
const idleKey = isSpeed ? 'idle_speed' : isTank ? 'idle_tank' : 'idle_jump';
const jumpKey = isSpeed ? 'jump_speed' : isTank ? 'jump_tank' : 'jump_jump';

if (!onGround) {
  if (this.player.anims.currentAnim?.key !== jumpKey) this.player.anims.play(jumpKey, true);
} else if (moving) {
  if (this.player.anims.currentAnim?.key !== walkKey) this.player.anims.play(walkKey, true);
} else {
  if (this.player.anims.currentAnim?.key !== idleKey) this.player.anims.play(idleKey, true);
}
```

**c) `collectCoin()` dispara ‚Äúpick‚Äù**
Inyecta esto despu√©s de sumar puntos/actualizar HUD: 

```ts
const pickKey = this.heroKey === 'hero_speed' ? 'pick_speed' :
                this.heroKey === 'hero_tank'  ? 'pick_tank'  : 'pick_jump';
const idleKey = this.heroKey === 'hero_speed' ? 'idle_speed' :
                this.heroKey === 'hero_tank'  ? 'idle_tank'  : 'idle_jump';

if (this.player.body!.touching.down) {
  this.player.anims.play(pickKey);
  this.player.once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
    this.player.anims.play(idleKey, true);
  });
}
```

## 4) `CharacterSelect.ts` (preview opcional)

Ahora que no hay `hero_*_1`, renderiza **frame 0** de cada hoja como preview o deja solo texto. Ejemplo:

```ts
const img = this.add.image(x, y - 10, 'hero_speed_sheet', 0).setScale(3);
```

El resto del selector (persistencia y `registry`) ya te sirve tal cual. 

---

# Script de tareas (Codex-friendly)

1. **Mover assets**: Copiar `hero_*_sheet.png` a `public/assets/`.
2. **Preloader.ts**

   * Eliminar contenido de `createHeroSprites()`.
   * A√±adir `load.spritesheet` para speed/jump/tank.
   * Reemplazar animaciones por `idle_*`, `walk_*`, `jump_*`, `pick_*`.
3. **Game.ts**

   * Cambiar `createPlayer()` para usar `*_sheet` + frame `0`.
   * En `update()`, usar `idle_*/walk_*/jump_*` como arriba.
   * En `collectCoin()`, reproducir `pick_*` y volver a `idle_*`.
4. **CharacterSelect.ts** (opcional)

   * Cambiar thumbs a `image(..., 'hero_*_sheet', 0)` o quitarlos.
5. **Probar**: `pnpm dev` y validar animaciones en: idle, correr, salto, recoger moneda.
6. **Ajustes finos**: Si quieres m√°s ‚Äúnervio‚Äù en el r√°pido, sube `frameRate` de `walk_speed` a 14‚Äì16; para tanque b√°jalo a 8‚Äì10.
7. **Commit**: `feat(hero): switch to spritesheet-based animations`.

---

¬øQuieres que tambi√©n te deje un **parche .diff** listo para aplicar sobre tu repo con todos los cambios?
</file>

<file path="env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="/style.css">
    <title>Goblins & Heroes</title>
</head>

<body>
    <div id="app">
        <div id="game-container"></div>
    </div>
    <script type="module" src="src/main.ts"></script>
</body>
</html>
</file>

<file path="JUEGO_PLATAFORMAS.md">
# üéÆ Goblins & Heroes

**Goblins & Heroes** es un emocionante juego de plataformas 2D desarrollado con **Phaser.js**, **Vue.js** y **TypeScript**.

## üéØ Objetivo del Juego

¬°Recoge todas las monedas doradas mientras evitas a los enemigos rojos! Llega a la cima del nivel para ganar.

## üïπÔ∏è Controles

- **‚Üê** y **‚Üí**: Mover izquierda y derecha
- **‚Üë**: Saltar
- **Rat√≥n**: Hacer clic para navegar por los men√∫s y seleccionar personaje

## üéÆ Mec√°nicas del Juego

### Elementos del Juego

- **Jugador**: Elige entre 3 h√©roes con ventajas √∫nicas:
  - **Velocidad**: M√°s r√°pido, menos vidas (2)
  - **Salto**: Salto m√°s alto, equilibrio general (3 vidas)
  - **Tanque**: M√°s vidas (4), menor velocidad
- **Plataformas (Marr√≥n)**: Superficies sobre las que puedes caminar y saltar
- **Monedas (Doradas)**: Rec√≥gelas todas para ganar (10 puntos cada una)
- **Enemigos (Rojos)**: Ev√≠talos o perder√°s una vida
 - **Puertas**: Tras completar un nivel, aparecen 2 puertas; cada una lleva a un siguiente nivel diferente (ramificaci√≥n)
 - **Jefe Final**: En el tercer nivel, aparece un jefe con poderes (proyectiles y teletransporte)

### Sistema de Puntuaci√≥n

- **Moneda recogida**: +10 puntos
- **Completar nivel**: +100 puntos de bonus
- **Vidas**: Empiezas con 3 vidas

### Condiciones de Victoria/Derrota

- **Victoria**: Recoge todas las 8 monedas doradas
- **Derrota**: Pierde todas las vidas (3) tocando enemigos o cayendo
- **Reinicio**: Si caes del mapa, regresas al punto de inicio

## üé® Caracter√≠sticas

- **Sprites procedurales**: Todos los sprites se generan mediante c√≥digo
- **F√≠sica realista**: Sistema de gravedad y colisiones
- **Enemigos con IA simple**: Se mueven de forma autom√°tica
- **Interfaz informativa**: Muestra puntuaci√≥n y vidas en tiempo real
- **Responsive design**: Se adapta a diferentes tama√±os de pantalla
- **Est√©tica pixel art**: Renderizado n√≠tido sin suavizado
- **Selecci√≥n de personaje**: 3 h√©roes con habilidades propias (Velocidad, Salto, Tanque)
- **Persistencia de selecci√≥n**: El personaje elegido se recuerda entre sesiones
 - **Pantalla de selecci√≥n dedicada**: Vista con descripci√≥n y confirmaci√≥n del h√©roe

## üöÄ Tecnolog√≠as Utilizadas

- **Phaser.js 3.90.0**: Motor de juegos 2D
- **Vue.js 3.5.13**: Framework frontend
- **TypeScript**: Tipado est√°tico
- **Vite**: Herramienta de desarrollo r√°pida
- **Arcade Physics**: Sistema de f√≠sica para colisiones

## üèóÔ∏è Estructura del Proyecto

```
src/game/scenes/
‚îú‚îÄ‚îÄ Boot.ts          # Inicializaci√≥n
‚îú‚îÄ‚îÄ Preloader.ts     # Carga de assets y sprites procedurales
‚îú‚îÄ‚îÄ MainMenu.ts      # Men√∫ principal
‚îú‚îÄ‚îÄ Game.ts          # L√≥gica principal del juego
‚îî‚îÄ‚îÄ GameOver.ts      # Pantalla de fin de juego
```

## üõ†Ô∏è Instalaci√≥n y Ejecuci√≥n

```bash
# Instalar dependencias
pnpm install

# Ejecutar en modo desarrollo
pnpm dev

# Construir para producci√≥n
pnpm build
```

## üéØ Pr√≥ximas Mejoras

- [x] M√∫ltiples niveles (3) con jefe final
- [x] Power-ups especiales
- [x] Efectos de sonido
- [x] Animaciones de sprites
- [ ] Sistema de puntuaciones altas
- [ ] Enemigos con patrones m√°s complejos
- [ ] Plataformas m√≥viles
- [ ] M√∫sica de fondo y control de volumen
- [ ] Indicador/temporizador de power-ups en HUD
- [ ] Soporte gamepad y controles t√°ctiles
- [ ] Transiciones de escena (fade/zoom) y efectos de c√°mara
- [ ] Sistema de niveles con mapas (Tiled) y tileset pixel art
- [ ] Men√∫ de pausa con reinicio r√°pido

 - [ ] Sistema de tesoros/reliquias evolutivas (exploraci√≥n con recompensa)
 - [ ] Progresi√≥n visual/jugable del h√©roe (armas/armaduras)
 - [ ] Goblins como guardianes de tesoros (llaves, minijefes, drops √∫nicos)
 - [ ] Inventario + UI de reliquias (equipar/descartar, slots, descripciones)
 - [ ] Loot tables y rarezas (com√∫n/ rara/ √©pica/ legendaria)
 - [ ] Santuarios/forjas para mejorar reliquias (costes y l√≠mites)
 - [ ] Mapas con secretos/cofres/puertas selladas por llaves
 - [ ] Meta‚Äëprogresi√≥n persistente entre partidas (desbloqueos globales)

## üß≠ Exploraci√≥n y Progresi√≥n (Propuesta)

- Identidad del juego: aventura + progresi√≥n din√°mica (no solo plataformas)
- Exploras el mapa y encuentras reliquias con efectos pasivos/activos
- Los goblins son guardianes de tesoros con prop√≥sito narrativo
- El h√©roe evoluciona visual y mec√°nicamente (stats, armas y armaduras)
- Implementaci√≥n modular y por fases para integrarse con la arquitectura actual

## üóùÔ∏è Reliquias (Propuestas)

| Tipo de reliquia | Efecto | Visual | Rareza |
| --- | --- | --- | --- |
| Amuleto de Vigor | +1 salto extra | Aura verde | Com√∫n |
| Cr√°neo R√∫nico | Ataque m√°gico cargado | Efecto p√∫rpura | Raro |
| Gema de la Sombra | Invisibilidad temporal | Sombras | √âpico |

Mec√°nica: al recoger, la reliquia se guarda en `player.relics` y activa una habilidad permanente o con cooldown seg√∫n su tipo.

| Tipo de reliquia | Efecto | Visual | Rareza |
| --- | --- | --- | --- |
| Corona del Rey Goblin | Aliados goblin temporalmente neutrales | Corona visible | Legendario |

## ‚öîÔ∏è Sistema de Armas y Armaduras

Equipamiento visible con impacto real en el juego.

| Slot | Ejemplo | Beneficio | Visual |
| --- | --- | --- | --- |
| Casco | Casco de Bronce | +10% defensa | Cambiado en sprite |
| Armadura | Cota de Escamas | Reduce da√±o | Sprite m√°s robusto |
| Arma | Ballesta | Disparos a distancia | Anim nueva |
| Escudo | Escudo de Torre | Parry / bloquear | Anim defensiva |

Notas:
- Inicio sugerido: 3 armas (espada b√°sica, ballesta, lanza).
- Cada arma cambia rango de ataque y animaciones del h√©roe.

## üëπ Nuevos Enemigos Tem√°ticos

Goblins guardianes:
- Guardias de tesoro: m√°s fuertes, defienden cofres.
- Chamanes: disparan magia, invocan cr√≠as.
- Goblins √©lite: equipados con cascos, sueltan partes de armadura al morir.

Nidos de cr√≠as:
- R√°pidas, atacan en enjambre.
- Ataque d√©bil; si te descuidas te paralizan saltando encima.
- Ideales para cuevas y zonas ocultas.

## üßç Progresi√≥n del Jugador (Visual + Gameplay)

- Escudo recogido ‚Üí aparece en el sprite (lado izquierdo) y permite bloquear/parry.
- Casco obtenido ‚Üí nueva cabeza/peinado/forma.
- Armadura equipada ‚Üí torso cambia (defensa efectiva).
- Arma equipada ‚Üí animaci√≥n y rango de ataque diferente.

Implementaci√≥n t√©cnica: sprites por capas (cabeza/torso/brazos/casco/arma) agrupados; Phaser soporta m√∫ltiples GameObjects por personaje.

## üß© Implementaci√≥n por Fases

Fase 1: Habilidades por tesoro (sin equipamiento visual a√∫n)
- A√±adir cofres con reliquias.
- Cada reliquia modifica atributos del h√©roe.
- Persisten entre niveles.

Fase 2: Equipables con cambios visuales
- Dividir sprite del h√©roe en capas.
- A√±adir slots: arma + casco + armadura.

Fase 3: Nuevos enemigos y nidos
- Grupo ‚Äúcr√≠as goblin‚Äù.
- Goblin guardi√°n con armadura y arma.
- Cofres protegidos por enemigos.

## üéÆ Tips para Jugar

1. **Explora todo el nivel**: Las monedas est√°n distribuidas en diferentes alturas
2. **Cuidado con los enemigos**: Se mueven constantemente, observa sus patrones
3. **Usa el salto estrat√©gicamente**: Algunos saltos requieren timing perfecto
4. **No tengas prisa**: Es mejor ir despacio que perder una vida
5. **La moneda final**: Est√° en la parte m√°s alta del nivel

¬°Disfruta del juego y trata de conseguir la puntuaci√≥n m√°s alta posible! üèÜ
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Phaser Studio Inc

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="log.js">
const fs = require('fs');
const https = require('https');

const main = async () => {
    const args = process.argv.slice(2);
    const packageData = JSON.parse(fs.readFileSync('./package.json', 'utf8'));
    const event = args[0] || 'unknown';
    const phaserVersion = packageData.dependencies.phaser;

    const options = {
        hostname: 'gryzor.co',
        port: 443,
        path: `/v/${event}/${phaserVersion}/${packageData.name}`,
        method: 'GET'
    };

    try {
        const req = https.request(options, (res) => {
            res.on('data', () => {});
            res.on('end', () => {
                process.exit(0);
            });
        });

        req.on('error', (error) => {
            process.exit(1);
        });

        req.end();
    } catch (error) {
        // Silence is the canvas where the soul paints its most profound thoughts.
        process.exit(1);
    }
}

main();
</file>

<file path="package.json">
{
    "name": "goblins-and-heroes",
    "description": "Goblins & Heroes ‚Äî juego de plataformas 2D en Phaser + Vue + TypeScript",
    "version": "1.0.0",
    "repository": {
        "type": "git",
        "url": "git+https://github.com/josantos/game-vuephaser.git"
    },
    "author": "Jos√© Santos",
    "license": "MIT",
    "keywords": [
        "phaser",
        "phaser3",
        "typescript",
        "vue",
        "vite",
        "plataformas",
        "juego",
        "2d"
    ],
    "scripts": {
        "dev": "node log.js dev & vite --config vite/config.dev.mjs",
        "build": "node log.js build & vite build --config vite/config.prod.mjs",
        "dev-nolog": "vite --config vite/config.dev.mjs",
        "build-nolog": "vite build --config vite/config.prod.mjs",
        "typecheck": "vue-tsc --noEmit"
    },
    "engines": {
        "node": ">=18"
    },
    "dependencies": {
        "phaser": "^3.90.0",
        "vue": "3.5.13"
    },
    "devDependencies": {
        "@types/node": "^20.11.20",
        "terser": "^5.31.0",
        "@vitejs/plugin-vue": "^5.2.2",
        "@vue/tsconfig": "^0.7.0",
        "typescript": "~5.7.2",
        "vite": "^6.3.1",
        "vue-tsc": "^2.2.8"
    }
}
</file>

<file path="pnpm-workspace.yaml">
onlyBuiltDependencies:
  - esbuild
</file>

<file path="public/style.css">
body {
    margin: 0;
    padding: 0;
    color: rgba(255, 255, 255, 0.87);
    background-color: #000000; 
    font-family: Arial, Helvetica, sans-serif;
}

#app {
    width: 100%;
    height: 100vh;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
}

#game-container canvas {
    image-rendering: pixelated;
    image-rendering: crisp-edges; /* fallback */
}

.spritePosition {
    margin: 10px 0 0 10px;
    font-size: 0.8em;
}

.button {
    width: 140px;
    margin: 10px;
    padding: 10px;
    background-color: #000000;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid rgba(255, 255, 255, 0.87);
    cursor: pointer;
    transition: all 0.3s;

    &:hover {
        border: 1px solid #0ec3c9;
        color: #0ec3c9;
    }

    &:active {
        background-color: #0ec3c9;
    }

    /* Disabled styles */
    &:disabled {
        cursor: not-allowed;
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: rgba(255, 255, 255, 0.3);
    }
}
</file>

<file path="README.md">
# Phaser Vue TypeScript Template

This is a Phaser 3 project template that uses the Vue framework, TypeScript and Vite for bundling. It includes a bridge for Vue to Phaser game communication, hot-reloading for quick development workflow and scripts to generate production-ready builds.

**[This Template is also available as a JavaScript version.](https://github.com/phaserjs/template-vue)**

### Versions

This template has been updated for:

- [Phaser 3.90.0](https://github.com/phaserjs/phaser)
- [Vue 3.5.13](https://github.com/vuejs)
- [Vite 6.3.1](https://github.com/vitejs/vite)
- [TypeScript 5.7.2](https://github.com/microsoft/TypeScript)

![screenshot](screenshot.png)

## Requirements

[Node.js](https://nodejs.org) is required to install dependencies and run scripts via `npm`.

## Available Commands

| Command | Description |
|---------|-------------|
| `npm install` | Install project dependencies |
| `npm run dev` | Launch a development web server |
| `npm run build` | Create a production build in the `dist` folder |
| `npm run dev-nolog` | Launch a development web server without sending anonymous data (see "About log.js" below) |
| `npm run build-nolog` | Create a production build in the `dist` folder without sending anonymous data (see "About log.js" below) |

## Writing Code

After cloning the repo, run `npm install` from your project directory. Then, you can start the local development server by running `npm run dev`.

The local development server runs on `http://localhost:8080` by default. Please see the Vite documentation if you wish to change this, or add SSL support.

Once the server is running you can edit any of the files in the `src` folder. Vite will automatically recompile your code and then reload the browser.

## Template Project Structure

We have provided a default project structure to get you started. This is as follows:

| Path                          | Description                                                                                     |
|-------------------------------|-------------------------------------------------------------------------------------------------|
| `index.html`                  | A basic HTML page to contain the game.                                                         |
| `src`                         | Contains the Vue source code.                                                                  |
| `src/main.ts`                 | The main **Vue** entry point. This bootstraps the Vue application.                             |
| `src/vite-env.d.ts`           | Global TypeScript declarations, providing type information.                                    |
| `src/App.vue`                 | The main Vue component.                                                                        |
| `src/PhaserGame.vue`     | The Vue component that initializes the Phaser Game and serves as a bridge between Vue and Phaser. |
| `src/game/EventBus.ts`        | A simple event bus to communicate between Vue and Phaser.                                      |
| `src/game`                    | Contains the game source code.                                                                |
| `src/game/main.ts`            | The main **game** entry point. This contains the game configuration and starts the game.       |
| `src/game/scenes/`            | The Phaser Scenes are in this folder.                                                         |
| `public/style.css`            | Some simple CSS rules to help with page layout.                                               |
| `public/assets`               | Contains the static assets used by the game.                                                  |

## Vue Bridge

The `PhaserGame.vue` component is the bridge between Vue and Phaser. It initializes the Phaser game and passes events between the two.

To communicate between Vue and Phaser, you can use the **EventBus.ts** file. This is a simple event bus that allows you to emit and listen for events from both Vue and Phaser.

```js
// In Vue
import { EventBus } from './EventBus';

// Emit an event
EventBus.emit('event-name', data);

// In Phaser
// Listen for an event
EventBus.on('event-name', (data) => {
    // Do something with the data
});
```

In addition to this, the `PhaserGame` component exposes the Phaser game instance along with the most recently active Phaser Scene. You can pick these up from Vue via `(defineExpose({ scene, game }))`.

Once exposed, you can access them like any regular state reference.

## Phaser Scene Handling

In Phaser, the Scene is the lifeblood of your game. It is where you sprites, game logic and all of the Phaser systems live. You can also have multiple scenes running at the same time. This template provides a way to obtain the current active scene from Vue.

You can get the current Phaser Scene from the component event `"current-active-scene"`. In order to do this, you need to emit the event `"current-scene-ready"` from the Phaser Scene class. This event should be emitted when the scene is ready to be used. You can see this done in all of the Scenes in our template.

**Important**: When you add a new Scene to your game, make sure you expose to Vue by emitting the `"current-scene-ready"` event via the `EventBus`, like this:


```js
class MyScene extends Phaser.Scene
{
    constructor ()
    {
        super('MyScene');
    }

    create ()
    {
        // Your Game Objects and logic here

        // At the end of create method:
        EventBus.emit('current-scene-ready', this);
    }
}
```

You don't have to emit this event if you don't need to access the specific scene from Vue. Also, you don't have to emit it at the end of `create`, you can emit it at any point. For example, should your Scene be waiting for a network request or API call to complete, it could emit the event once that data is ready.

### Vue Component Example

Here's an example of how to access Phaser data for use in a Vue Component:

```typescript
// In a parent component
<script setup lang="ts">
import { ref, toRaw } from 'vue';

const phaserRef = ref();
const game = toRaw(phaserRef.value.game) as Phaser.Game;
const scene = toRaw(phaserRef.value.scene) as Phaser.Scene;

const onCurrentActiveScene = (scene) => {
    
    // This is invoked

}

</script>
<template>
  <PhaserGame ref="phaserRef" @current-active-scene="onCurrentActiveScene" />
</template>
```

In the code above, you can get a reference to the current Phaser Game instance and the current Scene by calling `ref()`.

From this state reference, the game instance is available via `toRaw(phaserRef.value.game)` and the most recently active Scene via `toRaw(phaserRef.value.scene)`

The `onCurrentActiveScene` callback will also be invoked whenever the the Phaser Scene changes, as long as you emit the event via the EventBus, as outlined above.

## Handling Assets

Vite supports loading assets via JavaScript module `import` statements.

This template provides support for both embedding assets and also loading them from a static folder. To embed an asset, you can import it at the top of the JavaScript file you are using it in:

```js
import logoImg from './assets/logo.png'
```

To load static files such as audio files, videos, etc place them into the `public/assets` folder. Then you can use this path in the Loader calls within Phaser:

```js
preload ()
{
    //  This is an example of an imported bundled image.
    //  Remember to import it at the top of this file
    this.load.image('logo', logoImg);

    //  This is an example of loading a static image
    //  from the public/assets folder:
    this.load.image('background', 'assets/bg.png');
}
```

When you issue the `npm run build` command, all static assets are automatically copied to the `dist/assets` folder.

## Deploying to Production

After you run the `npm run build` command, your code will be built into a single bundle and saved to the `dist` folder, along with any other assets your project imported, or stored in the public assets folder.

In order to deploy your game, you will need to upload *all* of the contents of the `dist` folder to a public facing web server.

## Customizing the Template

### Vite

If you want to customize your build, such as adding plugin (i.e. for loading CSS or fonts), you can modify the `vite/config.*.mjs` file for cross-project changes, or you can modify and/or create new configuration files and target them in specific npm tasks inside of `package.json`. Please see the [Vite documentation](https://vitejs.dev/) for more information.

## About log.js

If you inspect our node scripts you will see there is a file called `log.js`. This file makes a single silent API call to a domain called `gryzor.co`. This domain is owned by Phaser Studio Inc. The domain name is a homage to one of our favorite retro games.

We send the following 3 pieces of data to this API: The name of the template being used (vue, react, etc). If the build was 'dev' or 'prod' and finally the version of Phaser being used.

At no point is any personal data collected or sent. We don't know about your project files, device, browser or anything else. Feel free to inspect the `log.js` file to confirm this.

Why do we do this? Because being open source means we have no visible metrics about which of our templates are being used. We work hard to maintain a large and diverse set of templates for Phaser developers and this is our small anonymous way to determine if that work is actually paying off, or not. In short, it helps us ensure we're building the tools for you.

However, if you don't want to send any data, you can use these commands instead:

Dev:

```bash
npm run dev-nolog
```

Build:

```bash
npm run build-nolog
```

Or, to disable the log entirely, simply delete the file `log.js` and remove the call to it in the `scripts` section of `package.json`:

Before:

```json
"scripts": {
    "dev": "node log.js dev & dev-template-script",
    "build": "node log.js build & build-template-script"
},
```

After:

```json
"scripts": {
    "dev": "dev-template-script",
    "build": "build-template-script"
},
```

Either of these will stop `log.js` from running. If you do decide to do this, please could you at least join our Discord and tell us which template you're using! Or send us a quick email. Either will be super-helpful, thank you.

## Join the Phaser Community!

We love to see what developers like you create with Phaser! It really motivates us to keep improving. So please join our community and show-off your work üòÑ

**Visit:** The [Phaser website](https://phaser.io) and follow on [Phaser Twitter](https://twitter.com/phaser_)<br />
**Play:** Some of the amazing games [#madewithphaser](https://twitter.com/search?q=%23madewithphaser&src=typed_query&f=live)<br />
**Learn:** [API Docs](https://newdocs.phaser.io), [Support Forum](https://phaser.discourse.group/) and [StackOverflow](https://stackoverflow.com/questions/tagged/phaser-framework)<br />
**Discord:** Join us on [Discord](https://discord.gg/phaser)<br />
**Code:** 2000+ [Examples](https://labs.phaser.io)<br />
**Read:** The [Phaser World](https://phaser.io/community/newsletter) Newsletter<br />

Created by [Phaser Studio](mailto:support@phaser.io). Powered by coffee, anime, pixels and love.

The Phaser logo and characters are &copy; 2011 - 2025 Phaser Studio Inc.

All rights reserved.
</file>

<file path="src/App.vue">
<script setup lang="ts">
import Phaser from 'phaser';
import { ref, type ComponentPublicInstance } from 'vue';
import type { MainMenu } from './game/scenes/MainMenu';
import PhaserGame from './PhaserGame.vue';

//  Typed reference to PhaserGame public instance (exposed props)
type PhaserGamePublic = ComponentPublicInstance<{
  scene: Phaser.Scene | null;
  game: Phaser.Game | null;
}>;

// The sprite can only be moved in the MainMenu Scene
const canMoveSprite = ref<boolean>(true);

//  References to the PhaserGame component (game and scene are exposed)
const phaserRef = ref<PhaserGamePublic | null>(null);
const spritePosition = ref<{ x: number; y: number }>({ x: 0, y: 0 });

const changeScene = () => {
  const scene = phaserRef.value?.scene as (MainMenu | null | undefined);
  if (scene && typeof (scene as any).changeScene === 'function') {
    scene.changeScene();
  }
};

const moveSprite = () => {
  const scene = phaserRef.value?.scene as (MainMenu | null | undefined);
  if (scene && typeof (scene as any).moveLogo === 'function') {
    scene.moveLogo(({ x, y }) => {
      spritePosition.value = { x, y };
    });
  }
};

const addSprite = () => {
  const scene = phaserRef.value?.scene as Phaser.Scene | null | undefined;
  if (scene) {
    const x = Phaser.Math.Between(64, scene.scale.width - 64);
    const y = Phaser.Math.Between(64, scene.scale.height - 64);
    const star = scene.add.sprite(x, y, 'star');
    scene.add.tween({
      targets: star,
      duration: 500 + Math.random() * 1000,
      alpha: 0,
      yoyo: true,
      repeat: -1
    });
  }
};

// Event emitted from the PhaserGame component
const currentScene = (scene: Phaser.Scene) => {
  canMoveSprite.value = (scene.scene.key !== 'MainMenu');
};

</script>

<template>
    <PhaserGame ref="phaserRef" @current-active-scene="currentScene" />
    <div>
        <div>
            <button class="button" @click="changeScene">Change Scene</button>
        </div>
        <div>
            <button :disabled="canMoveSprite" class="button" @click="moveSprite">Toggle Movement</button>
        </div>
        <div class="spritePosition">Sprite Position:
            <pre>{{ spritePosition }}</pre>
        </div>
        <div>
            <button class="button" @click="addSprite">Add New Sprite</button>
        </div>
    </div>
</template>
</file>

<file path="src/game/audio/Sfx.ts">
import { Scene } from 'phaser';

export type WaveType = OscillatorType;

// Simple WebAudio SFX helper using Phaser's audio context
export class Sfx {
  static tone(
    scene: Scene,
    freq: number,
    duration = 0.15,
    type: WaveType = 'sine',
    volume = 0.2
  ) {
    // Use Phaser WebAudio context when available
    // @ts-expect-error Phaser typing for sound.context exists at runtime
    const ctx: AudioContext | undefined = scene.sound?.context as any;
    if (!ctx || (ctx as any).state === 'closed') return; // Fallback: skip when no WebAudio or closed

    const t0 = ctx.currentTime;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);

    // Quick attack, short decay envelope
    gain.gain.setValueAtTime(0, t0);
    gain.gain.linearRampToValueAtTime(volume, t0 + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + duration);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(t0);
    osc.stop(t0 + duration + 0.02);
  }

  static click(scene: Scene) {
    this.tone(scene, 600, 0.05, 'square', 0.15);
  }

  static jump(scene: Scene) {
    this.tone(scene, 420, 0.12, 'square', 0.2);
  }

  static coin(scene: Scene) {
    // Two short blips
    this.tone(scene, 880, 0.06, 'triangle', 0.22);
    setTimeout(() => this.tone(scene, 1320, 0.07, 'triangle', 0.2), 50);
  }

  static hit(scene: Scene) {
    this.tone(scene, 180, 0.2, 'sawtooth', 0.25);
  }

  static win(scene: Scene) {
    const notes = [660, 880, 990, 1320];
    notes.forEach((f, i) => setTimeout(() => this.tone(scene, f, 0.08, 'triangle', 0.2), i * 90));
  }

  static gameOver(scene: Scene) {
    this.tone(scene, 300, 0.18, 'sine', 0.22);
    setTimeout(() => this.tone(scene, 220, 0.22, 'sine', 0.22), 160);
  }

  static powerUp(scene: Scene) {
    const notes = [523, 659, 784];
    notes.forEach((f, i) => setTimeout(() => this.tone(scene, f, 0.06, 'square', 0.18), i * 70));
  }
}
</file>

<file path="src/game/boss/BossController.ts">
import { Scene } from 'phaser';

export class BossController {
  private scene: Scene;
  private boss?: Phaser.Physics.Arcade.Sprite;
  private projectiles?: Phaser.Physics.Arcade.Group;
  private shootTimer?: Phaser.Time.TimerEvent;
  private teleportTimer?: Phaser.Time.TimerEvent;

  constructor(scene: Scene) {
    this.scene = scene;
  }

  getProjectiles(): Phaser.Physics.Arcade.Group | undefined {
    return this.projectiles;
  }

  getBoss(): Phaser.Physics.Arcade.Sprite | undefined {
    return this.boss;
  }

  start(platforms: Phaser.Physics.Arcade.StaticGroup, player: Phaser.Physics.Arcade.Sprite): void {
    const boss = this.scene.physics.add.sprite(700, 300, 'boss_troll_sheet', 0) as Phaser.Physics.Arcade.Sprite;
    this.boss = boss;
    boss.setCollideWorldBounds(true);
    boss.setScale(1.2);
    const body = boss.body as Phaser.Physics.Arcade.Body;
    // Ajustar hitbox para asegurar colisi√≥n robusta con plataformas
    body.setSize(48, 56, true);
    body.setBounce(0, 0);
    body.setMaxVelocity(400, 1000);
    this.scene.physics.add.collider(boss, platforms);
    this.scene.physics.add.overlap(player, boss, (_p: any, _b: any) => {
      // Delegate handling to scene via event to keep controller generic
      this.scene.events.emit('boss-hit-player');
    });
    boss.play('troll_idle');

    this.projectiles = this.scene.physics.add.group();

    this.shootTimer = this.scene.time.addEvent({
      delay: 1500,
      loop: true,
      callback: () => {
        if (!this.boss) return;
        boss.play('troll_cast');
        boss.once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
          if (!this.boss || !this.projectiles) return;
          const proj = this.projectiles.create(boss.x, boss.y, 'projectile') as Phaser.Physics.Arcade.Image;
          const angle = Phaser.Math.Angle.Between(boss.x, boss.y, player.x, player.y);
          const speed = 220;
          proj.setVelocity(Math.cos(angle) * speed, Math.sin(angle) * speed);
          boss.play('troll_idle');
        });
      }
    });

    this.teleportTimer = this.scene.time.addEvent({
      delay: 4000,
      loop: true,
      callback: () => {
        if (!this.boss) return;
        boss.play('troll_portal');
        boss.once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
          if (!this.boss) return;
          const spots = [ {x: 250, y: 300}, {x: 750, y: 260}, {x: 500, y: 200} ];
          const s = Phaser.Utils.Array.GetRandom(spots);
          boss.setPosition(s.x, s.y);
          const b = boss.body as Phaser.Physics.Arcade.Body;
          // Resetear velocidad tras teletransporte para evitar atravesar por alta VY
          b.setVelocity(0, 0);
          this.scene.cameras.main.flash(150, 255, 255, 255);
          boss.play('troll_idle');
        });
      }
    });
  }

  dispose(): void {
    try { this.shootTimer?.remove(false); } catch {}
    try { this.teleportTimer?.remove(false); } catch {}
    try { this.projectiles?.destroy(true); } catch {}
    try { this.boss?.destroy(); } catch {}
    this.shootTimer = undefined;
    this.teleportTimer = undefined;
    this.projectiles = undefined;
    this.boss = undefined;
  }
}
</file>

<file path="src/game/core/Hero.ts">
export type HeroKey = 'hero_speed' | 'hero_jump' | 'hero_tank';

export interface HeroStats {
  speedX: number;
  jumpV: number;
  lives: number;
}

export class HeroStatsService {
  static getStats(key: HeroKey): HeroStats {
    switch (key) {
      case 'hero_speed':
        return { speedX: 420, jumpV: -600, lives: 2 };
      case 'hero_tank':
        return { speedX: 250, jumpV: -600, lives: 4 };
      case 'hero_jump':
      default:
        return { speedX: 300, jumpV: -750, lives: 3 };
    }
  }

  static getSheetKey(key: HeroKey): string {
    if (key === 'hero_speed') return 'hero_speed_sheet';
    if (key === 'hero_tank') return 'hero_tank_sheet';
    return 'hero_jump_sheet';
  }

  static getLabel(key: HeroKey): string {
    if (key === 'hero_speed') return 'Velocidad';
    if (key === 'hero_tank') return 'Tanque';
    return 'Salto';
  }
}
</file>

<file path="src/game/doors/DoorController.ts">
import { Scene } from 'phaser';

export class DoorController {
  private scene: Scene;
  private doors?: Phaser.Physics.Arcade.StaticGroup;

  constructor(scene: Scene) {
    this.scene = scene;
  }

  spawn(
    player: Phaser.Physics.Arcade.Sprite,
    platforms: Phaser.Physics.Arcade.StaticGroup,
    levelIndex: number,
    pathChoice: 'A' | 'B',
    onEnter: (choice: 'A' | 'B') => void
  ): void {
    if (this.doors && this.doors.getChildren().length > 0) return;
    this.doors = this.scene.physics.add.staticGroup();

    const [xA, xB] = this.getDoorXs(levelIndex, pathChoice);
    const yA = this.getDoorYForX(platforms, xA);
    const yB = this.getDoorYForX(platforms, xB);

    const doorA = this.doors.create(xA, yA, 'door') as Phaser.Physics.Arcade.Image;
    const doorB = this.doors.create(xB, yB, 'door') as Phaser.Physics.Arcade.Image;
    doorA.setDepth(80);
    doorB.setDepth(80);

    const glowA = this.scene.add.image(xA, yA - 10, 'door_glow').setDepth(70).setAlpha(0.7);
    glowA.setBlendMode(Phaser.BlendModes.ADD);
    const glowB = this.scene.add.image(xB, yB - 10, 'door_glow').setDepth(70).setAlpha(0.7);
    glowB.setBlendMode(Phaser.BlendModes.ADD);
    this.scene.tweens.add({ targets: [glowA, glowB], alpha: 0.4, yoyo: true, repeat: -1, duration: 700 });

    const arrowA = this.scene.add.image(xA, yA - 40, 'door_arrow').setDepth(90);
    const arrowB = this.scene.add.image(xB, yB - 40, 'door_arrow').setDepth(90);
    this.scene.tweens.add({ targets: [arrowA, arrowB], y: '+=8', yoyo: true, repeat: -1, duration: 500, ease: 'Sine.easeInOut' });

    this.scene.physics.add.overlap(player, doorA, () => onEnter('A'));
    this.scene.physics.add.overlap(player, doorB, () => onEnter('B'));
  }

  private getDoorXs(level: number, choice: 'A' | 'B'): [number, number] {
    if (level === 1) return [100, 900];
    if (level === 2) return choice === 'A' ? [420, 820] : [520, 900];
    return [300, 740];
  }

  private getDoorYForX(platforms: Phaser.Physics.Arcade.StaticGroup, x: number): number {
    let y = 420;
    const children = platforms.getChildren() as any[];
    children.forEach((obj: any) => {
      if (!obj || typeof obj.x !== 'number' || typeof obj.y !== 'number') return;
      const w = (obj.displayWidth ?? 100);
      const h = (obj.displayHeight ?? 20);
      const halfW = w / 2;
      if (x >= obj.x - halfW && x <= obj.x + halfW) {
        const top = obj.y - h / 2;
        const candidate = top - 24;
        if (candidate < y) y = candidate;
      }
    });
    return y;
  }
}
</file>

<file path="src/game/EventBus.ts">
import { Events } from 'phaser';

// Used to emit events between components, HTML and Phaser scenes
export const EventBus = new Events.EventEmitter();
</file>

<file path="src/game/main.ts">
import { Boot } from './scenes/Boot';
import { GameOver } from './scenes/GameOver';
import { Game as MainGame } from './scenes/Game';
import { MainMenu } from './scenes/MainMenu';
import { CharacterSelect } from './scenes/CharacterSelect';
import { LevelSelectDev } from './scenes/LevelSelectDev';
import { AUTO, Game } from 'phaser';
import { Preloader } from './scenes/Preloader';

// Find out more information about the Game Config at:
// https://docs.phaser.io/api-documentation/typedef/types-core#gameconfig
const config: Phaser.Types.Core.GameConfig = {
    type: AUTO,
    width: 1024,
    height: 768,
    parent: 'game-container',
    backgroundColor: '#028af8',
    pixelArt: true,
    render: { antialias: false },
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 800, x: 0 },
            debug: false
        }
    },
    scene: [
        Boot,
        Preloader,
        MainMenu,
        CharacterSelect,
        LevelSelectDev,
        MainGame,
        GameOver
    ]
};

const StartGame = (parent: string) => {

    return new Game({ ...config, parent });

}

export default StartGame;
</file>

<file path="src/game/scenes/Boot.ts">
import { Scene } from 'phaser';

export class Boot extends Scene
{
    constructor ()
    {
        super('Boot');
    }

    preload ()
    {
        //  The Boot Scene is typically used to load in any assets you require for your Preloader, such as a game logo or background.
        //  The smaller the file size of the assets, the better, as the Boot Scene itself has no preloader.

        this.load.image('background', 'assets/bg.png');
    }

    create ()
    {
        this.scene.start('Preloader');
    }
}
</file>

<file path="src/game/scenes/CharacterSelect.ts">
import { Scene, GameObjects } from 'phaser';
import { EventBus } from '../EventBus';
import { Sfx } from '../audio/Sfx';

type HeroKey = 'hero_speed' | 'hero_jump' | 'hero_tank';

export class CharacterSelect extends Scene {
  background!: GameObjects.Image;
  title!: GameObjects.Text;
  selected: HeroKey = 'hero_jump';
  frames: Phaser.GameObjects.Rectangle[] = [];
  imgs: Phaser.GameObjects.Image[] = [];
  info!: Phaser.GameObjects.Text;
  confirmBtn!: Phaser.GameObjects.Text;
  backBtn!: Phaser.GameObjects.Text;

  constructor() {
    super('CharacterSelect');
  }

  create() {
    this.background = this.add.image(512, 384, 'background');

    this.title = this.add.text(512, 120, 'Selecciona tu h√©roe', {
      fontFamily: 'Arial Black', fontSize: 48, color: '#ffffff',
      stroke: '#000000', strokeThickness: 8, align: 'center'
    }).setOrigin(0.5).setDepth(100);

    try {
      const saved = window.localStorage.getItem('selectedHero') as HeroKey | null;
      if (saved) this.selected = saved;
    } catch {}

    this.layoutHeroes();
    this.updateInfo();

    this.confirmBtn = this.add.text(512, 650, 'Confirmar', {
      fontFamily: 'Arial Black', fontSize: 36, color: '#00ff00', stroke: '#000000', strokeThickness: 6
    }).setOrigin(0.5).setDepth(100).setInteractive({ useHandCursor: true });
    this.confirmBtn.on('pointerdown', () => {
      Sfx.click(this);
      this.registry.set('selectedHero', this.selected);
      // Reset de progreso de niveles al iniciar una nueva partida
      this.registry.set('levelIndex', 1);
      this.registry.set('path', '');
      this.registry.set('carryScore', 0);
      this.registry.set('carryLives', undefined);
      try { window.localStorage.setItem('selectedHero', this.selected); } catch {}
      this.scene.start('Game');
    });

    this.backBtn = this.add.text(100, 720, '‚Üê Volver', {
      fontFamily: 'Arial', fontSize: 24, color: '#ffff00', stroke: '#000000', strokeThickness: 4
    }).setOrigin(0, 1).setDepth(100).setInteractive({ useHandCursor: true });
    this.backBtn.on('pointerdown', () => {
      Sfx.click(this);
      this.scene.start('MainMenu');
    });

    EventBus.emit('current-scene-ready', this);
  }

  private layoutHeroes() {
    const defs: { key: HeroKey; sheet: string; label: string }[] = [
      { key: 'hero_speed', sheet: 'hero_speed_sheet', label: 'Velocidad' },
      { key: 'hero_jump', sheet: 'hero_jump_sheet', label: 'Salto' },
      { key: 'hero_tank', sheet: 'hero_tank_sheet', label: 'Tanque' }
    ];
    const startX = 260;
    const y = 360;
    const gap = 260;

    defs.forEach((h, i) => {
      const x = startX + i * gap;
      const frame = this.add.rectangle(x, y, 120, 120).setStrokeStyle(6, 0xffffff).setDepth(90);
      const img = this.add.image(x, y - 10, h.sheet, 0).setScale(3).setInteractive({ useHandCursor: true }).setDepth(100);
      this.add.text(x, y + 70, h.label, { fontFamily: 'Arial Black', fontSize: 22, color: '#ffffff', stroke: '#000000', strokeThickness: 4 }).setOrigin(0.5).setDepth(100);

      img.on('pointerdown', () => {
        Sfx.click(this);
        this.selected = h.key;
        try { window.localStorage.setItem('selectedHero', this.selected); } catch {}
        this.updateFrames();
        this.updateInfo();
      });

      this.frames.push(frame);
      this.imgs.push(img);
    });

    this.updateFrames();
  }

  private updateFrames() {
    const order: HeroKey[] = ['hero_speed', 'hero_jump', 'hero_tank'];
    this.frames.forEach((f, idx) => {
      const active = order[idx] === this.selected;
      f.setStrokeStyle(6, active ? 0xffff00 : 0xffffff);
    });
  }

  private updateInfo() {
    const map: Record<HeroKey, { name: string; desc: string; stats: string }> = {
      hero_speed: {
        name: 'Velocidad',
        desc: 'Se mueve m√°s r√°pido, pero con menos vidas.',
        stats: 'Velocidad: Alta | Salto: Medio | Vidas: 2'
      },
      hero_jump: {
        name: 'Salto',
        desc: 'Mayor altura de salto y balance general.',
        stats: 'Velocidad: Media | Salto: Alto | Vidas: 3'
      },
      hero_tank: {
        name: 'Tanque',
        desc: 'M√°s resistencia con m√°s vidas, menor velocidad.',
        stats: 'Velocidad: Baja | Salto: Medio | Vidas: 4'
      }
    };
    const i = map[this.selected];
    if (!this.info) {
      this.info = this.add.text(512, 500, `${i.name}\n${i.desc}\n${i.stats}`, {
        fontFamily: 'Arial', fontSize: 22, color: '#ffffff', stroke: '#000000', strokeThickness: 4, align: 'center'
      }).setOrigin(0.5).setDepth(100);
    } else {
      this.info.setText(`${i.name}\n${i.desc}\n${i.stats}`);
    }
  }
}
</file>

<file path="src/game/scenes/Game.ts">
import { EventBus } from '../EventBus';
import { Sfx } from '../audio/Sfx';
import { Scene } from 'phaser';
import { HeroKey, HeroStatsService } from '../core/Hero';
import { Hud } from '../ui/Hud';
import { EnemySpawner } from '../spawners/EnemySpawner';
import { CoinSpawner } from '../spawners/CoinSpawner';
import { PowerUpSpawner } from '../spawners/PowerUpSpawner';
import { BossController } from '../boss/BossController';
import { DoorController } from '../doors/DoorController';

export class Game extends Scene
{
    camera: Phaser.Cameras.Scene2D.Camera;
    background: Phaser.GameObjects.Image;
    heroKey: HeroKey = 'hero_jump';
    levelIndex: number = 1;
    path: string = '';
    
    // Elementos del juego
    player!: Phaser.Physics.Arcade.Sprite;
    platforms!: Phaser.Physics.Arcade.StaticGroup;
    enemies!: Phaser.Physics.Arcade.Group;
    coins!: Phaser.Physics.Arcade.Group;
    powerUps!: Phaser.Physics.Arcade.Group;
    cursors!: Phaser.Types.Input.Keyboard.CursorKeys;
    spaceKey!: Phaser.Input.Keyboard.Key;
    wasd!: { left: Phaser.Input.Keyboard.Key; right: Phaser.Input.Keyboard.Key; up: Phaser.Input.Keyboard.Key };
    
    // UI
    hud!: Hud;
    
    // Variables del juego
    score: number = 0;
    lives: number = 3;
    gameWon: boolean = false;
    speedX: number = 300;
    jumpV: number = -600;
    invincible: boolean = false;
    levelComplete: boolean = false;
    bossCtrl?: BossController;
    doorCtrl?: DoorController;
    totalCoins: number = 0;

    constructor ()
    {
        super('Game');
    }

    create ()
    {
        this.camera = this.cameras.main;
        this.camera.setBackgroundColor(0x87CEEB); // Azul cielo
        this.camera.roundPixels = true; // Evitar sub-pixel blur en pixel art

        // Reset de estado de nivel al (re)entrar
        this.gameWon = false;
        this.levelComplete = false;
        this.invincible = false;
        try { this.doorCtrl = new DoorController(this); } catch {}
        try { this.bossCtrl?.dispose(); } catch {}
        this.bossCtrl = undefined;

        // Selecci√≥n de h√©roe
        const sel = this.registry.get('selectedHero');
        if (sel && (sel === 'hero_speed' || sel === 'hero_jump' || sel === 'hero_tank')) {
            this.heroKey = sel;
        }

        // Estado de nivel y camino
        const idx = this.registry.get('levelIndex');
        this.levelIndex = typeof idx === 'number' ? idx : 1;
        const p = this.registry.get('path');
        this.path = typeof p === 'string' ? p : '';

        const stats = HeroStatsService.getStats(this.heroKey);
        this.speedX = stats.speedX;
        this.jumpV = stats.jumpV;
        this.lives = stats.lives;

        // Continuidad de puntuaci√≥n/vidas despu√©s de aplicar stats base
        const carryScore = this.registry.get('carryScore');
        if (typeof carryScore === 'number') this.score = carryScore;
        const carryLives = this.registry.get('carryLives');
        if (typeof carryLives === 'number') this.lives = carryLives;

        // Crear plataformas
        this.createPlatforms();
        
        // Crear jugador
        this.createPlayer();
        
        // Inicializar grupos
        this.enemies = this.physics.add.group();
        this.coins = this.physics.add.group();
        this.powerUps = this.physics.add.group();

        // Crear enemigos
        const enemySpawner = new EnemySpawner();
        enemySpawner.spawn(this, this.enemies, this.levelIndex, this.getPathChoice());
        
        // Crear monedas
        const coinSpawner = new CoinSpawner();
        coinSpawner.spawn(this, this.coins, this.levelIndex, this.getPathChoice(), this.platforms);
        this.totalCoins = this.coins.getChildren().length;

        // Crear power-ups
        const powerUpSpawner = new PowerUpSpawner();
        powerUpSpawner.spawn(this, this.powerUps);

        // Jefe en nivel 3
        if (this.levelIndex >= 3) {
            this.bossCtrl = new BossController(this);
            this.bossCtrl.start(this.platforms, this.player);
        }
        
        // Configurar controles (flechas + WASD) y capturas de teclado
        this.cursors = this.input.keyboard!.createCursorKeys();
        this.spaceKey = this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
        this.input.keyboard!.addCapture(['UP','DOWN','LEFT','RIGHT','SPACE','W','A','S','D']);
        this.wasd = {
            left: this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.A),
            right: this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.D),
            up: this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.W)
        };
        
        // Crear UI
        this.hud = new Hud(this, this.score, this.lives, this.totalCoins);
        // Texto de h√©roe y stats (arriba derecha)
        const heroLabel = HeroStatsService.getLabel(this.heroKey);
        const statsTxt = `VEL ${this.speedX} | SALTO ${Math.abs(this.jumpV)} | VIDAS ${this.lives}`;
        this.add.text(1024 - 16, 16, `Nivel: ${this.levelIndex}\nH√©roe: ${heroLabel}\n${statsTxt}`, {
            fontSize: '20px',
            color: '#000',
            align: 'right'
        }).setOrigin(1, 0);
        
        // Configurar f√≠sica
        this.setupPhysics();

        // Bridge boss controller overlap back to scene logic
        this.events.on('boss-hit-player', () => this.hitEnemy(this.player, null));

        EventBus.emit('current-scene-ready', this);
    }

    createPlatforms()
    {
        this.platforms = this.physics.add.staticGroup();
        
        // Plataforma base
        this.platforms.create(512, 768, 'platform').setScale(10, 1).refreshBody();

        const choice = this.getPathChoice();
        if (this.levelIndex === 1) {
            this.levelLayoutA();
        } else if (this.levelIndex === 2) {
            choice === 'A' ? this.levelLayoutA2() : this.levelLayoutB2();
        } else {
            choice === 'A' ? this.levelLayoutA3() : this.levelLayoutB3();
        }
    }

    createPlayer()
    {
        const sheet = HeroStatsService.getSheetKey(this.heroKey);
        this.player = this.physics.add.sprite(100, 700, sheet, 0);
        this.player.setBounce(0.2);
        this.player.setCollideWorldBounds(true);
        this.player.setScale(1);
    }

    

    setupPhysics()
    {
        // Colisiones del jugador con plataformas
        this.physics.add.collider(this.player, this.platforms);
        
        // Colisiones de enemigos con plataformas
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Las monedas NO colisionan con plataformas (flotan libremente)
        
        // Los power-ups flotan; no colisionan con plataformas
        
        // Colisi√≥n jugador con enemigos
        this.physics.add.overlap(this.player, this.enemies, this.hitEnemy, undefined, this);
        
        // Colisi√≥n jugador con monedas
        this.physics.add.overlap(this.player, this.coins, this.collectCoin, undefined, this);

        // Colisi√≥n jugador con power-ups
        this.physics.add.overlap(this.player, this.powerUps, this.collectPowerUp, undefined, this);

        // Proyectiles del jefe
        if (this.bossCtrl?.getProjectiles()) {
            const projs = this.bossCtrl.getProjectiles()!;
            this.physics.add.overlap(this.player, projs, this.hitEnemy, undefined, this);
            this.physics.add.collider(projs, this.platforms, (proj: any) => proj.destroy());
        }
    }

    update()
    {
        // Controles del jugador (flechas o WASD)
        const leftPressed = (this.cursors?.left?.isDown) || this.wasd?.left?.isDown;
        const rightPressed = (this.cursors?.right?.isDown) || this.wasd?.right?.isDown;
        if (leftPressed)
        {
            this.player.setVelocityX(-this.speedX);
            this.player.setFlipX(true);
        }
        else if (rightPressed)
        {
            this.player.setVelocityX(this.speedX);
            this.player.setFlipX(false);
        }
        else
        {
            this.player.setVelocityX(0);
        }

        if (this.player.body!.touching.down)
        {
            const upKey = this.cursors?.up;
            const wKey = this.wasd?.up;
            const space = this.spaceKey;
            if ((upKey && Phaser.Input.Keyboard.JustDown(upKey)) || (wKey && Phaser.Input.Keyboard.JustDown(wKey)) || Phaser.Input.Keyboard.JustDown(space))
            {
                this.player.setVelocityY(this.jumpV);
                Sfx.jump(this);
            }
        }
        
        // Animaciones: caminar / salto / idle
        const onGround = this.player.body!.touching.down;
        const vx = this.player.body!.velocity.x;
        const moving = Math.abs(vx) > 10 && onGround;

        const isSpeed = this.heroKey === 'hero_speed';
        const isTank = this.heroKey === 'hero_tank';
        const walkKey = isSpeed ? 'walk_speed' : isTank ? 'walk_tank' : 'walk_jump';
        const idleKey = isSpeed ? 'idle_speed' : isTank ? 'idle_tank' : 'idle_jump';
        const jumpKey = isSpeed ? 'jump_speed' : isTank ? 'jump_tank' : 'jump_jump';

        if (!onGround) {
            if (this.player.anims.currentAnim?.key !== jumpKey) {
                this.player.anims.play(jumpKey, true);
            }
        } else if (moving) {
            if (this.player.anims.currentAnim?.key !== walkKey) {
                this.player.anims.play(walkKey, true);
            }
        } else {
            if (this.player.anims.currentAnim?.key !== idleKey) {
                this.player.anims.play(idleKey, true);
            }
        }

        // Reiniciar si el jugador cae
        if (this.player.y > 800)
        {
            this.resetPlayerPosition();
        }

        // Flip horizontal de duendes seg√∫n direcci√≥n de movimiento
        this.enemies.children.iterate((e: any) => {
            const s = e as Phaser.Physics.Arcade.Sprite;
            if (s.body) s.setFlipX((s.body as any).velocity.x < 0);
            return true;
        });
        
        // Verificar victoria (nunca m√°s de una vez)
        if (this.coins.countActive(true) === 0 && !this.gameWon)
        {
            this.gameWon = true;

            // Bonus por completar el nivel
            this.score += 100;
            this.hud.updateScore(this.score);

            if (this.levelIndex >= 3)
            {
                // Fin de la partida tras el jefe
                this.registry.set('finalScore', this.score);
                this.add.text(512, 384, '¬°GANASTE!', {
                    fontSize: '64px', color: '#00ff00', stroke: '#000000', strokeThickness: 4
                }).setOrigin(0.5);
                Sfx.win(this);
                this.time.delayedCall(2500, () => { this.scene.start('GameOver'); });
            }
            else
            {
                this.levelComplete = true;
                this.invincible = true;
                Sfx.win(this);
                this.add.text(512, 120, 'Elige una puerta', { fontSize: '40px', color: '#ffff00', stroke: '#000', strokeThickness: 4 }).setOrigin(0.5);
                // Retrasar un frame para asegurar que colisionadores/plataformas est√©n listos
                this.time.delayedCall(50, () => {
                    if (!this.doorCtrl) this.doorCtrl = new DoorController(this);
                    this.doorCtrl.spawn(this.player, this.platforms, this.levelIndex, this.getPathChoice(), (choice) => this.enterDoor(choice));
                });
            }
        }
    }

    private floatText(x: number, y: number, msg: string, color = '#ffff00')
    {
        const t = this.add.text(x, y, msg, { fontSize: '20px', color, stroke: '#000', strokeThickness: 3 }).setOrigin(0.5);
        this.tweens.add({ targets: t, y: y - 30, alpha: 0, duration: 700, onComplete: () => t.destroy() });
    }

    collectPowerUp(_player: any, pu: any)
    {
        const type = pu.getData('ptype');
        const glow = pu.getData('glow');
        
        // Destruir el glow asociado
        if (glow && glow.active) {
            glow.destroy();
        }
        
        pu.disableBody(true, true);
        Sfx.powerUp(this);

        // mini destello donde estaba el power-up
        const flash = this.add.rectangle(pu.x, pu.y, 10, 10, 0xffffff, 0.9).setDepth(999);
        this.tweens.add({ targets: flash, scaleX: 6, scaleY: 6, alpha: 0, duration: 220, onComplete: () => flash.destroy() });

        switch (type) {
            case 'life':
                this.lives += 1;
                this.hud.updateLives(this.lives);
                this.floatText(pu.x, pu.y, '+1 Vida', '#2ecc71');
                break;
            case 'speed':
                this.floatText(pu.x, pu.y, 'Velocidad +', '#3498db');
                this.speedX = 450;
                this.jumpV = -700;
                this.player.setTint(0x3498db);
                // pulso corto en el player
                this.tweens.add({ targets: this.player, scaleX: 1.06, scaleY: 1.06, yoyo: true, duration: 120 });
                this.time.delayedCall(5000, () => {
                    this.speedX = 300;
                    this.jumpV = -600;
                    this.player.clearTint();
                });
                break;
            case 'inv':
                this.floatText(pu.x, pu.y, 'Invencible', '#f1c40f');
                this.invincible = true;
                this.player.setTint(0xf1c40f);
                // aura r√°pida
                const aura = this.add.circle(this.player.x, this.player.y, 22, 0xffff66, 0.2).setDepth(1).setBlendMode(Phaser.BlendModes.ADD);
                const follow = this.time.addEvent({ delay: 16, loop: true, callback: () => aura.setPosition(this.player.x, this.player.y) });
                this.tweens.add({ targets: aura, alpha: 0.35, yoyo: true, repeat: -1, duration: 300 });
                this.time.delayedCall(4000, () => {
                    this.invincible = false;
                    this.player.clearTint();
                    aura.destroy();
                    follow.remove(false);
                });
                break;
        }
    }

    createPowerUps()
    {
        this.powerUps = this.physics.add.group();

        const items = [
            { x: 500, y: 520, key: 'pu_speed_sheet', anim: 'pu_speed_idle', type: 'speed' },
            { x: 850, y: 370, key: 'pu_inv_sheet', anim: 'pu_inv_idle', type: 'inv' },
            { x: 150, y: 120, key: 'pu_life_sheet', anim: 'pu_life_idle', type: 'life' }
        ];

        items.forEach(i => {
            // Verificar textura
            const tex = this.textures.get(i.key);
            if (!tex || tex.key === '__MISSING') {
                console.error(`‚ùå Textura ${i.key} no encontrada`);
                return;
            }
            
            const pu = this.powerUps.create(i.x, i.y, i.key, 0) as Phaser.Physics.Arcade.Sprite;
            pu.play(i.anim);
            
            // Escala moderada y sin f√≠sicas que lo muevan
            pu.setScale(1.5);
            pu.setBounce(0);
            pu.setCollideWorldBounds(false);
            pu.setData('ptype', i.type);
            
            // Hitbox ajustada (sprites de 32x32 escalados a 2.0 = 64x64)
            pu.body!.setSize(20, 20).setOffset(2, 2);

            // Flotantes: sin gravedad ni empuje
            (pu.body as Phaser.Physics.Arcade.Body).setAllowGravity(false);
            pu.setImmovable(true);

            // Efecto de flotaci√≥n pronunciado
            this.tweens.add({
                targets: pu,
                y: pu.y - 4,
                duration: 1100,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.inOut'
            });

            // Efecto de pulso muy sutil en la escala
            this.tweens.add({
                targets: pu,
                scaleX: 1.55,
                scaleY: 1.55,
                duration: 1200,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.inOut'
            });

            // A√±adir un glow circular peque√±o y muy sutil detr√°s seg√∫n el tipo
            let glowColor = 0xffffff;
            if (i.type === 'life') glowColor = 0xff6b9d; // Rosa/rojo para vida
            else if (i.type === 'speed') glowColor = 0x4fc3f7; // Azul cyan para velocidad
            else if (i.type === 'inv') glowColor = 0xffd700; // Dorado para invencibilidad

            const glow = this.add.circle(i.x, i.y, 14, glowColor, 0.12);
            glow.setDepth(pu.depth - 1);
            glow.setBlendMode(Phaser.BlendModes.ADD);

            // Pulso del glow muy sutil
            this.tweens.add({
                targets: glow,
                alpha: 0.2,
                scale: 1.1,
                duration: 1400,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.inOut'
            });

            // Vincular el glow al movimiento del power-up
            pu.setData('glow', glow);
            
            // Actualizar posici√≥n del glow en cada frame
            this.events.on('update', () => {
                if (pu.active && glow.active) {
                    glow.setPosition(pu.x, pu.y);
                }
            });
        });
        
        console.log(`‚ö° Creados ${items.length} power-ups`);
    }

    collectCoin(_player: any, coin: any)
    {
        // Crear efecto de part√≠culas en la posici√≥n de la moneda
        const particles = this.add.particles(coin.x, coin.y, 'coin_sheet', {
            speed: { min: 50, max: 100 },
            scale: { start: 0.5, end: 0 },
            lifespan: 300,
            quantity: 5
        });
        
        // Eliminar el efecto despu√©s de un tiempo
        this.time.delayedCall(300, () => {
            particles.destroy();
        });
        
        coin.disableBody(true, true);
        this.score += 10;
        this.hud.updateScore(this.score);
        
        // Actualizar contador de monedas
        const coinsRemaining = this.coins.countActive(true);
        const collected = this.totalCoins - coinsRemaining;
        this.hud.updateCoins(collected, this.totalCoins);

        Sfx.coin(this);

        // Reproducir animaci√≥n de "pick"
        const pickKey = this.heroKey === 'hero_speed' ? 'pick_speed' :
                        this.heroKey === 'hero_tank' ? 'pick_tank' : 'pick_jump';
        const idleKey = this.heroKey === 'hero_speed' ? 'idle_speed' :
                        this.heroKey === 'hero_tank' ? 'idle_tank' : 'idle_jump';

        if (this.player.body!.touching.down) {
            this.player.anims.play(pickKey);
            this.player.once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
                this.player.anims.play(idleKey, true);
            });
        }
    }

    hitEnemy(_player: any, _enemy: any)
    {
        if (this.invincible) {
            return;
        }
        Sfx.hit(this);
        // Efecto de vibraci√≥n de la c√°mara
        this.cameras.main.shake(500, 0.02);
        
        // Efecto visual de da√±o (parpadeo del jugador)
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        this.lives--;
        this.hud.updateLives(this.lives);
        
        if (this.lives <= 0)
        {
            this.gameOver();
        }
        else
        {
            this.resetPlayerPosition();
        }
    }

    resetPlayerPosition()
    {
        this.player.setPosition(100, 700);
        this.player.setVelocity(0, 0);
    }

    gameOver()
    {
        // Guardar puntuaci√≥n final
        this.registry.set('finalScore', this.score);

        Sfx.gameOver(this);

        this.add.text(512, 384, 'GAME OVER', {
            fontSize: '64px',
            color: '#ff0000',
            stroke: '#000000',
            strokeThickness: 4
        }).setOrigin(0.5);
        
        this.time.delayedCall(3000, () => {
            this.scene.start('GameOver');
        });
    }

    changeScene ()
    {
        this.scene.start('GameOver');
    }

    private getPathChoice(): 'A' | 'B'
    {
        if (this.levelIndex === 1) return 'A';
        const idx = this.levelIndex - 2;
        const c = this.path.charAt(idx);
        return c === 'B' ? 'B' : 'A';
    }

    private levelLayoutA() {
        this.platforms.create(200, 650, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(500, 550, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(800, 450, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(200, 350, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(600, 250, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(100, 150, 'platform').setScale(1.5, 1).refreshBody();
        this.platforms.create(900, 150, 'platform').setScale(1.5, 1).refreshBody();
    }
    private levelLayoutA2() {
        this.platforms.create(220, 620, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(420, 520, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(680, 420, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(820, 320, 'platform').setScale(1.5, 1).refreshBody();
        this.platforms.create(512, 240, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(150, 180, 'platform').setScale(1.5, 1).refreshBody();
        this.platforms.create(900, 180, 'platform').setScale(1.5, 1).refreshBody();
    }
    private levelLayoutB2() {
        this.platforms.create(300, 600, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(520, 540, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(740, 480, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(900, 360, 'platform').setScale(1.5, 1).refreshBody();
        this.platforms.create(620, 260, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(420, 200, 'platform').setScale(1.5, 1).refreshBody();
        this.platforms.create(200, 160, 'platform').setScale(1.5, 1).refreshBody();
    }
    private levelLayoutA3() {
        this.platforms.create(250, 560, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(500, 460, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(750, 360, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(300, 260, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(600, 160, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(900, 160, 'platform').setScale(1.5, 1).refreshBody();
    }
    private levelLayoutB3() {
        this.platforms.create(200, 600, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(450, 520, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(700, 420, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(900, 300, 'platform').setScale(1.5, 1).refreshBody();
        this.platforms.create(550, 220, 'platform').setScale(2, 1).refreshBody();
        this.platforms.create(300, 180, 'platform').setScale(1.5, 1).refreshBody();
    }


    private enterDoor(choice: 'A' | 'B') {
        if (!this.levelComplete) return;
        const nextIndex = this.levelIndex + 1;
        const nextPath = this.path + choice;
        this.registry.set('levelIndex', nextIndex);
        this.registry.set('path', nextPath);
        this.registry.set('carryScore', this.score);
        this.registry.set('carryLives', this.lives);
        this.scene.restart();
    }
    
}
</file>

<file path="src/game/scenes/GameOver.ts">
import { EventBus } from '../EventBus';
import { Sfx } from '../audio/Sfx';
import { Scene } from 'phaser';

export class GameOver extends Scene
{
    camera: Phaser.Cameras.Scene2D.Camera;
    background: Phaser.GameObjects.Image;
    gameOverText : Phaser.GameObjects.Text;

    constructor ()
    {
        super('GameOver');
    }

    create ()
    {
        this.camera = this.cameras.main
        this.camera.setBackgroundColor(0x2c3e50);

        this.background = this.add.image(512, 384, 'background');
        this.background.setAlpha(0.3);

        this.gameOverText = this.add.text(512, 300, 'Fin del Juego', {
            fontFamily: 'Arial Black', fontSize: 64, color: '#ffffff',
            stroke: '#000000', strokeThickness: 8,
            align: 'center'
        }).setOrigin(0.5).setDepth(100);

        // Mostrar puntuaci√≥n final si est√° disponible
        const finalScore = this.registry.get('finalScore') || 0;
        this.add.text(512, 400, `Puntuaci√≥n Final: ${finalScore}`, {
            fontFamily: 'Arial', fontSize: 32, color: '#ffffff',
            stroke: '#000000', strokeThickness: 4,
            align: 'center'
        }).setOrigin(0.5).setDepth(100);

        // Bot√≥n para volver al men√∫
        this.add.text(512, 500, 'Haz clic para volver al men√∫', {
            fontFamily: 'Arial', fontSize: 24, color: '#ffff00',
            stroke: '#000000', strokeThickness: 4,
            align: 'center'
        }).setOrigin(0.5).setDepth(100);

        // Hacer la pantalla clickeable para volver al men√∫
        this.input.once('pointerdown', () => {
            Sfx.click(this);
            this.changeScene();
        });
        
        EventBus.emit('current-scene-ready', this);
    }

    changeScene ()
    {
        this.scene.start('MainMenu');
    }
}
</file>

<file path="src/game/scenes/LevelSelectDev.ts">
import { Scene } from 'phaser';
import { Sfx } from '../audio/Sfx';

export class LevelSelectDev extends Scene {
  constructor() {
    super('LevelSelectDev');
  }

  create() {
    this.add.text(512, 120, 'DEV: Seleccionar Nivel', {
      fontFamily: 'Arial Black', fontSize: 48, color: '#ffff00',
      stroke: '#000000', strokeThickness: 8, align: 'center'
    }).setOrigin(0.5);

    const options: { label: string; level: number; path: string }[] = [
      { label: 'Nivel 1', level: 1, path: '' },
      { label: 'Nivel 2A', level: 2, path: 'A' },
      { label: 'Nivel 2B', level: 2, path: 'B' },
      { label: 'Nivel 3A', level: 3, path: 'AA' },
      { label: 'Nivel 3B', level: 3, path: 'AB' }
    ];

    const startX = 240;
    const y = 300;
    const gap = 150;

    options.forEach((opt, i) => {
      const x = startX + (i % 3) * gap;
      const rowY = y + Math.floor(i / 3) * 120;
      const btn = this.add.text(x, rowY, opt.label, {
        fontFamily: 'Arial Black', fontSize: 32, color: '#00ff00', stroke: '#000000', strokeThickness: 6
      }).setOrigin(0.5).setInteractive({ useHandCursor: true });

      btn.on('pointerdown', () => {
        Sfx.click(this);
        this.registry.set('levelIndex', opt.level);
        this.registry.set('path', opt.path);
        this.registry.set('carryScore', 0);
        this.registry.set('carryLives', undefined);
        this.scene.start('Game');
      });
    });

    // Volver al men√∫
    const back = this.add.text(512, 600, 'Volver al Men√∫', {
      fontFamily: 'Arial', fontSize: 24, color: '#ffff00', stroke: '#000000', strokeThickness: 4
    }).setOrigin(0.5).setInteractive({ useHandCursor: true });
    back.on('pointerdown', () => {
      Sfx.click(this);
      this.scene.start('MainMenu');
    });
  }
}
</file>

<file path="src/game/scenes/MainMenu.ts">
import { GameObjects, Scene } from 'phaser';
import { EventBus } from '../EventBus';
import { Sfx } from '../audio/Sfx';

export class MainMenu extends Scene
{
    background: GameObjects.Image;
    intro: GameObjects.Image;
    title: GameObjects.Text;
    logoTween: Phaser.Tweens.Tween | null;
    // Pantalla principal limpia, selecci√≥n se mueve a CharacterSelect

    constructor ()
    {
        super('MainMenu');
    }

    create ()
    {
        this.background = this.add.image(512, 384, 'background');

        // Agregar imagen de intro como portada del juego, centrada y escalada
        this.intro = this.add.image(512, 500, 'intro')
            .setDepth(100); // Escalar un poco para que ocupe m√°s espacio

        // // Agregar efecto de parpadeo (fade in/out suave)
        // this.tweens.add({
        //     targets: this.intro,
        //     alpha: { from: 0.6, to: 1.0 },
        //     duration: 1500,
        //     yoyo: true,
        //     repeat: -1,
        //     ease: 'Sine.inOut'
        // });

        this.title = this.add.text(512, 350, 'Goblins & Heroes', {
            fontFamily: 'Arial Black', fontSize: 48, color: '#ffffff',
            stroke: '#000000', strokeThickness: 8,
            align: 'center'
        }).setOrigin(0.5).setDepth(100);

        // Instrucciones del juego
        this.add.text(512, 450, 'Usa las flechas para moverte\nFlecha arriba o Espacio para saltar\nRecoge todas las monedas\nEvita los enemigos rojos', {
            fontFamily: 'Arial', fontSize: 24, color: '#ffffff',
            stroke: '#000000', strokeThickness: 4,
            align: 'center'
        }).setOrigin(0.5).setDepth(100);

        // Bot√≥n para ir al selector de personajes
        this.add.text(512, 620, 'Haz clic para elegir personaje', {
            fontFamily: 'Arial Black', fontSize: 32, color: '#ffff00',
            stroke: '#000000', strokeThickness: 6,
            align: 'center'
        }).setOrigin(0.5).setDepth(100);

        // Hacer la pantalla clickeable para iniciar el juego
        this.input.once('pointerdown', () => {
            Sfx.click(this);
            this.changeScene();
        });

        // DEV: acceso r√°pido al selector de nivel
        if (import.meta.env.DEV) {
            this.add.text(16, 740, 'DEV: Seleccionar nivel', {
                fontFamily: 'Arial', fontSize: 20, color: '#00ff00', stroke: '#000000', strokeThickness: 4
            }).setOrigin(0, 1).setDepth(100).setInteractive({ useHandCursor: true })
            .on('pointerdown', () => {
                Sfx.click(this);
                this.scene.start('LevelSelectDev');
            });
        }

        EventBus.emit('current-scene-ready', this);
    }
    
    changeScene ()
    {
        if (this.logoTween)
        {
            this.logoTween.stop();
            this.logoTween = null;
        }
        this.scene.start('CharacterSelect');
    }

    moveLogo (vueCallback: ({ x, y }: { x: number, y: number }) => void)
    {
        if (this.logoTween)
        {
            if (this.logoTween.isPlaying())
            {
                this.logoTween.pause();
            }
            else
            {
                this.logoTween.play();
            }
        } 
        else
        {
            this.logoTween = this.tweens.add({
                targets: this.intro,
                x: { value: 750, duration: 3000, ease: 'Back.easeInOut' },
                y: { value: 80, duration: 1500, ease: 'Sine.easeOut' },
                yoyo: true,
                repeat: -1,
                onUpdate: () => {
                    if (vueCallback)
                    {
                        vueCallback({
                            x: Math.floor(this.intro.x),
                            y: Math.floor(this.intro.y)
                        });
                    }
                }
            });
        }
    }

    // Selecci√≥n movida a CharacterSelect
}
</file>

<file path="src/game/scenes/Preloader.ts">
import { Scene } from 'phaser';

export class Preloader extends Scene
{
    constructor ()
    {
        super('Preloader');
    }

    init ()
    {
        //  We loaded this image in our Boot Scene, so we can display it here
        this.add.image(512, 384, 'background');

        //  A simple progress bar. This is the outline of the bar.
        this.add.rectangle(512, 384, 468, 32).setStrokeStyle(1, 0xffffff);

        //  This is the progress bar itself. It will increase in size from the left based on the % of progress.
        const bar = this.add.rectangle(512-230, 384, 4, 28, 0xffffff);

        //  Use the 'progress' event emitted by the LoaderPlugin to update the loading bar
        this.load.on('progress', (progress: number) => {

            //  Update the progress bar (our bar is 464px wide, so 100% = 464px)
            bar.width = 4 + (460 * progress);

        });
    }

    preload ()
    {
        //  Load the assets for the game - Replace with your own assets
        this.load.setPath('assets');

        this.load.image('logo', 'logo.png');
        this.load.image('star', 'star.png');
        this.load.image('intro', 'intro.png');
        
        // Cargar spritesheets de h√©roes
        this.load.spritesheet('hero_speed_sheet', 'hero_speed_sheet.png', { frameWidth: 32, frameHeight: 32 });
        this.load.spritesheet('hero_jump_sheet', 'hero_jump_sheet.png', { frameWidth: 32, frameHeight: 32 });
        this.load.spritesheet('hero_tank_sheet', 'hero_tank_sheet.png', { frameWidth: 32, frameHeight: 32 });

        // Cargar spritesheets de enemigos y jefe
        this.load.spritesheet('goblin_green_sheet', 'goblin_green_sheet.png', { frameWidth: 32, frameHeight: 32 });
        this.load.spritesheet('goblin_red_sheet', 'goblin_red_sheet.png', { frameWidth: 32, frameHeight: 32 });
        this.load.spritesheet('boss_troll_sheet', 'boss_troll_sheet.png', { frameWidth: 64, frameHeight: 64 });

        // Cargar spritesheets de monedas y power-ups
        // Formato unificado: 8√ó3 grid de 32√ó32 por celda = 256√ó96 total
        // 8 frames de animaci√≥n en la primera fila (frames 0-7)
        // Las filas 2 y 3 est√°n transparentes (frames 8-23)
        
        this.load.spritesheet('coin_sheet', 'coin_sheet_like_hero.png', { 
            frameWidth: 32, 
            frameHeight: 32 
        });
        
        this.load.spritesheet('pu_life_sheet', 'pu_life_sheet_like_hero.png', { 
            frameWidth: 32, 
            frameHeight: 32 
        });
        
        this.load.spritesheet('pu_speed_sheet', 'pu_speed_sheet_like_hero.png', { 
            frameWidth: 32, 
            frameHeight: 32 
        });
        
        this.load.spritesheet('pu_inv_sheet', 'pu_inv_sheet_like_hero.png', { 
            frameWidth: 32, 
            frameHeight: 32 
        });

        // Event listener para verificar carga exitosa
        this.load.on('filecomplete', (key: string) => {
            if (key.includes('coin_sheet') || key.includes('pu_')) {
                console.log(`‚úÖ Cargado: ${key}`);
                const tex = this.textures.get(key);
                if (tex) {
                    console.log(`   Dimensiones: ${tex.source[0].width}x${tex.source[0].height}`);
                }
            }
        });
        
        // Crear sprites proceduralmente para el juego de plataformas (player/platform/enemy/doors)
        this.createPlayerSprite();
        this.createPlatformSprite();
        this.createEnemySprite();
        // Monedas y power-ups vendr√°n de spritesheets ‚Äî no generamos aqu√≠
        this.createDoorAndBossSprites();
    }

    createPlayerSprite()
    {
        // Crear un sprite del jugador (cuadrado azul)
        const graphics = this.add.graphics();
        graphics.fillStyle(0x3498db);
        graphics.fillRect(0, 0, 32, 32);
        graphics.generateTexture('player', 32, 32);
        graphics.destroy();
    }

    createPlatformSprite()
    {
        // Crear sprite de plataforma (rect√°ngulo marr√≥n)
        const graphics = this.add.graphics();
        graphics.fillStyle(0x8B4513);
        graphics.fillRect(0, 0, 100, 20);
        graphics.generateTexture('platform', 100, 20);
        graphics.destroy();
    }

    createEnemySprite()
    {
        // Crear sprite de enemigo (c√≠rculo rojo)
        const graphics = this.add.graphics();
        graphics.fillStyle(0xe74c3c);
        graphics.fillCircle(16, 16, 16);
        graphics.generateTexture('enemy', 32, 32);
        graphics.destroy();
    }

    createCoinSprite() { /* no-op, usamos spritesheet */ }
    createPowerUpSprites() { /* no-op, usamos spritesheet */ }

    createDoorAndBossSprites()
    {
        // Puerta (marr√≥n con marco claro)
        let g = this.add.graphics();
        g.fillStyle(0x8B4513);
        g.fillRect(0, 0, 32, 48);
        g.lineStyle(3, 0xdeb887);
        g.strokeRect(0, 0, 32, 48);
        g.fillStyle(0x3e2723); g.fillRect(10, 20, 12, 12); // pomo
        g.generateTexture('door', 32, 48);
        g.destroy();

        // Proyectil (orbe morado)
        g = this.add.graphics();
        g.fillStyle(0x8e44ad); g.fillCircle(6, 6, 6);
        g.lineStyle(2, 0xffffff); g.strokeCircle(6, 6, 6);
        g.generateTexture('projectile', 12, 12);
        g.destroy();

        // Jefe (enemigo grande)
        g = this.add.graphics();
        g.fillStyle(0xc0392b);
        g.fillCircle(32, 32, 32);
        g.lineStyle(4, 0x000000); g.strokeCircle(32, 32, 32);
        g.generateTexture('boss', 64, 64);
        g.destroy();

        // Glow de puerta (c√≠rculo amarillo con alpha)
        g = this.add.graphics();
        for (let r = 44; r >= 16; r -= 8) {
            const alpha = (r - 12) / 44 * 0.25;
            g.fillStyle(0xfff176, alpha);
            g.fillCircle(48, 48, r);
        }
        g.generateTexture('door_glow', 96, 96);
        g.destroy();

        // Flecha gu√≠a (tri√°ngulo)
        g = this.add.graphics();
        g.fillStyle(0xffff00, 1);
        g.fillTriangle(12, 24, 24, 24, 18, 8);
        g.lineStyle(2, 0x000000, 0.8);
        g.strokeTriangle(12, 24, 24, 24, 18, 8);
        g.generateTexture('door_arrow', 36, 32);
        g.destroy();
    }

    createHeroSprites()
    {
        // Funci√≥n eliminada - ahora usamos spritesheets desde assets
    }

    create ()
    {
        // Definir animaciones para cada h√©roe desde las spritesheets
        
        // SPEED
        this.anims.create({ key: 'idle_speed', frames: this.anims.generateFrameNumbers('hero_speed_sheet', { start: 0, end: 3 }), frameRate: 6, repeat: -1 });
        this.anims.create({ key: 'walk_speed', frames: this.anims.generateFrameNumbers('hero_speed_sheet', { start: 4, end: 9 }), frameRate: 12, repeat: -1 });
        this.anims.create({ key: 'jump_speed', frames: this.anims.generateFrameNumbers('hero_speed_sheet', { start: 10, end: 12 }), frameRate: 8, repeat: 0 });
        this.anims.create({ key: 'pick_speed', frames: this.anims.generateFrameNumbers('hero_speed_sheet', { start: 13, end: 16 }), frameRate: 10, repeat: 0 });

        // JUMP
        this.anims.create({ key: 'idle_jump', frames: this.anims.generateFrameNumbers('hero_jump_sheet', { start: 0, end: 3 }), frameRate: 6, repeat: -1 });
        this.anims.create({ key: 'walk_jump', frames: this.anims.generateFrameNumbers('hero_jump_sheet', { start: 4, end: 9 }), frameRate: 12, repeat: -1 });
        this.anims.create({ key: 'jump_jump', frames: this.anims.generateFrameNumbers('hero_jump_sheet', { start: 10, end: 12 }), frameRate: 8, repeat: 0 });
        this.anims.create({ key: 'pick_jump', frames: this.anims.generateFrameNumbers('hero_jump_sheet', { start: 13, end: 16 }), frameRate: 10, repeat: 0 });

        // TANK
        this.anims.create({ key: 'idle_tank', frames: this.anims.generateFrameNumbers('hero_tank_sheet', { start: 0, end: 3 }), frameRate: 5, repeat: -1 });
        this.anims.create({ key: 'walk_tank', frames: this.anims.generateFrameNumbers('hero_tank_sheet', { start: 4, end: 9 }), frameRate: 10, repeat: -1 });
        this.anims.create({ key: 'jump_tank', frames: this.anims.generateFrameNumbers('hero_tank_sheet', { start: 10, end: 12 }), frameRate: 6, repeat: 0 });
        this.anims.create({ key: 'pick_tank', frames: this.anims.generateFrameNumbers('hero_tank_sheet', { start: 13, end: 16 }), frameRate: 8, repeat: 0 });

        // GOBLINS (verde y rojo comparten animaciones)
        this.anims.create({ key: 'goblin_idle', frames: this.anims.generateFrameNumbers('goblin_green_sheet', { start: 0, end: 3 }), frameRate: 6, repeat: -1 });
        this.anims.create({ key: 'goblin_run', frames: this.anims.generateFrameNumbers('goblin_green_sheet', { start: 4, end: 9 }), frameRate: 10, repeat: -1 });
        this.anims.create({ key: 'goblin_atk', frames: this.anims.generateFrameNumbers('goblin_green_sheet', { start: 10, end: 12 }), frameRate: 8, repeat: 0 });
        this.anims.create({ key: 'goblin_hit', frames: this.anims.generateFrameNumbers('goblin_green_sheet', { start: 13, end: 16 }), frameRate: 10, repeat: 0 });

        // TROLL (jefe)
        this.anims.create({ key: 'troll_idle', frames: this.anims.generateFrameNumbers('boss_troll_sheet', { start: 0, end: 3 }), frameRate: 5, repeat: -1 });
        this.anims.create({ key: 'troll_run', frames: this.anims.generateFrameNumbers('boss_troll_sheet', { start: 4, end: 9 }), frameRate: 8, repeat: -1 });
        this.anims.create({ key: 'troll_cast', frames: this.anims.generateFrameNumbers('boss_troll_sheet', { start: 10, end: 12 }), frameRate: 8, repeat: 0 });
        this.anims.create({ key: 'troll_portal', frames: this.anims.generateFrameNumbers('boss_troll_sheet', { start: 13, end: 16 }), frameRate: 10, repeat: 0 });

        // MONEDA: animaci√≥n de giro (8 frames de la fila 0)
        this.anims.create({ 
            key: 'coin_spin', 
            frames: this.anims.generateFrameNumbers('coin_sheet', { start: 0, end: 7 }), 
            frameRate: 12, 
            repeat: -1 
        });

        // POWER-UPS: pulso suave (8 frames de la fila 0)
        this.anims.create({ 
            key: 'pu_life_idle', 
            frames: this.anims.generateFrameNumbers('pu_life_sheet', { start: 0, end: 7 }), 
            frameRate: 6, 
            repeat: -1 
        });
        
        this.anims.create({ 
            key: 'pu_speed_idle', 
            frames: this.anims.generateFrameNumbers('pu_speed_sheet', { start: 0, end: 7 }), 
            frameRate: 12, 
            repeat: -1 
        });
        
        this.anims.create({ 
            key: 'pu_inv_idle', 
            frames: this.anims.generateFrameNumbers('pu_inv_sheet', { start: 0, end: 7 }), 
            frameRate: 8, 
            repeat: -1 
        });

        // Forzar filtro NEAREST en TODAS las texturas pixel art (Phaser 3.60+)
        const allSheets = [
            'coin_sheet', 'pu_life_sheet', 'pu_speed_sheet', 'pu_inv_sheet',
            'hero_speed_sheet', 'hero_jump_sheet', 'hero_tank_sheet',
            'goblin_green_sheet', 'goblin_red_sheet', 'boss_troll_sheet'
        ];
        allSheets.forEach(k => {
            const texture = this.textures.get(k);
            if (texture && texture.key !== '__MISSING') {
                texture.setFilter(Phaser.Textures.FilterMode.NEAREST);
            } else {
                console.warn(`Textura "${k}" no encontrada o no cargada correctamente`);
            }
        });

        //  Mover al men√∫ principal
        this.scene.start('MainMenu');
    }
}
</file>

<file path="src/game/spawners/CoinSpawner.ts">
import { Scene } from 'phaser';
import { getTopYForX } from '../utils/PlatformUtils';

export class CoinSpawner {
  spawn(
    scene: Scene,
    group: Phaser.Physics.Arcade.Group,
    levelIndex: number,
    pathChoice: 'A' | 'B',
    platforms: Phaser.Physics.Arcade.StaticGroup
  ): void {
    let coins: { x: number; y: number }[] = [];
    if (levelIndex === 1) {
      coins = [
        { x: 250, y: 600 }, { x: 550, y: 500 }, { x: 850, y: 400 },
        { x: 250, y: 300 }, { x: 650, y: 200 }, { x: 150, y: 100 },
        { x: 950, y: 100 }, { x: 512, y: 50 }
      ];
    } else if (levelIndex === 2) {
      coins = pathChoice === 'A'
        ? [
            { x: 200, y: 600 }, { x: 400, y: 520 }, { x: 680, y: 420 },
            { x: 820, y: 320 }, { x: 512, y: 240 }, { x: 150, y: 180 },
            { x: 900, y: 180 }, { x: 512, y: 80 }
          ]
        : [
            { x: 300, y: 580 }, { x: 520, y: 520 }, { x: 740, y: 460 },
            { x: 900, y: 360 }, { x: 620, y: 260 }, { x: 420, y: 200 },
            { x: 200, y: 160 }, { x: 850, y: 120 }
          ];
    } else {
      coins = pathChoice === 'A'
        ? [
            { x: 250, y: 560 }, { x: 500, y: 460 }, { x: 750, y: 360 },
            { x: 300, y: 260 }, { x: 600, y: 160 }, { x: 900, y: 160 },
            { x: 150, y: 120 }, { x: 512, y: 80 }
          ]
        : [
            { x: 200, y: 600 }, { x: 450, y: 520 }, { x: 700, y: 420 },
            { x: 900, y: 300 }, { x: 550, y: 220 }, { x: 300, y: 180 },
            { x: 150, y: 140 }, { x: 512, y: 100 }
          ];
    }

    coins.forEach((pos) => {
      const platformTop = getTopYForX(platforms, pos.x);
      const spawnY = Math.min(pos.y, platformTop - 24); // clampa sobre plataforma
      const coin = group.create(pos.x, spawnY, 'coin_sheet', 0) as Phaser.Physics.Arcade.Sprite;
      coin.play('coin_spin');
      coin.setScale(1);
      (coin.body as Phaser.Physics.Arcade.Body).setAllowGravity(false);
      coin.setImmovable(true);
      coin.setBounce(0);
      coin.body!.setSize(20, 20).setOffset(2, 2);
      scene.tweens.add({ targets: coin, y: spawnY - 2, yoyo: true, repeat: -1, duration: 700, ease: 'Sine.inOut' });
    });
  }
}
</file>

<file path="src/game/spawners/EnemySpawner.ts">
import { Scene } from 'phaser';

export class EnemySpawner {
  spawn(
    _scene: Scene,
    group: Phaser.Physics.Arcade.Group,
    levelIndex: number,
    pathChoice: 'A' | 'B'
  ): void {
    let positions: { x: number; y: number }[] = [];
    if (levelIndex === 1) {
      positions = [
        { x: 500, y: 500 },
        { x: 800, y: 400 },
        { x: 200, y: 300 },
        { x: 600, y: 200 }
      ];
    } else if (levelIndex === 2) {
      positions = pathChoice === 'A'
        ? [ { x: 300, y: 520 }, { x: 700, y: 420 } ]
        : [ { x: 200, y: 480 }, { x: 850, y: 280 }, { x: 500, y: 360 } ];
    } else {
      positions = pathChoice === 'A'
        ? [ { x: 250, y: 500 }, { x: 750, y: 300 } ]
        : [ { x: 400, y: 520 }, { x: 900, y: 380 } ];
    }

    positions.forEach((pos, idx) => {
      const key = (idx % 2 === 0) ? 'goblin_green_sheet' : 'goblin_red_sheet';
      const gob = group.create(pos.x, pos.y, key, 0) as Phaser.Physics.Arcade.Sprite;
      gob.setBounce(1).setCollideWorldBounds(true);
      gob.setVelocity(Phaser.Math.Between(-200, 200), 0);
      gob.setScale(1.5);
      gob.body!.setSize(20, 26).setOffset(6, 6);
      gob.play('goblin_run');
    });
  }
}
</file>

<file path="src/game/spawners/PowerUpSpawner.ts">
import { Scene } from 'phaser';

export class PowerUpSpawner {
  spawn(scene: Scene, group: Phaser.Physics.Arcade.Group): void {
    const items = [
      { x: 500, y: 520, key: 'pu_speed_sheet', anim: 'pu_speed_idle', type: 'speed' },
      { x: 850, y: 370, key: 'pu_inv_sheet', anim: 'pu_inv_idle', type: 'inv' },
      { x: 150, y: 120, key: 'pu_life_sheet', anim: 'pu_life_idle', type: 'life' }
    ];

    items.forEach(i => {
      const tex = scene.textures.get(i.key);
      if (!tex || tex.key === '__MISSING') {
        console.error(`Textura ${i.key} no encontrada`);
        return;
      }

      const pu = group.create(i.x, i.y, i.key, 0) as Phaser.Physics.Arcade.Sprite;
      pu.play(i.anim);
      pu.setScale(1.5);
      pu.setBounce(0);
      pu.setCollideWorldBounds(false);
      pu.setData('ptype', i.type);
      pu.body!.setSize(20, 20).setOffset(2, 2);
      (pu.body as Phaser.Physics.Arcade.Body).setAllowGravity(false);
      pu.setImmovable(true);

      scene.tweens.add({ targets: pu, y: pu.y - 4, duration: 1100, yoyo: true, repeat: -1, ease: 'Sine.inOut' });
      scene.tweens.add({ targets: pu, scaleX: 1.55, scaleY: 1.55, duration: 1200, yoyo: true, repeat: -1, ease: 'Sine.inOut' });

      let glowColor = 0xffffff;
      if (i.type === 'life') glowColor = 0xff6b9d;
      else if (i.type === 'speed') glowColor = 0x4fc3f7;
      else if (i.type === 'inv') glowColor = 0xffd700;

      const glow = scene.add.circle(i.x, i.y, 14, glowColor, 0.12);
      glow.setDepth(pu.depth - 1);
      glow.setBlendMode(Phaser.BlendModes.ADD);
      scene.tweens.add({ targets: glow, alpha: 0.2, scale: 1.1, duration: 1400, yoyo: true, repeat: -1, ease: 'Sine.inOut' });
      pu.setData('glow', glow);

      scene.events.on('update', () => {
        if (pu.active && glow.active) {
          glow.setPosition(pu.x, pu.y);
        }
      });
    });

    console.log(`Creados ${items.length} power-ups`);
  }
}
</file>

<file path="src/game/ui/Hud.ts">
import { Scene } from 'phaser';

export interface IHUD {
  updateScore(score: number): void;
  updateLives(lives: number): void;
  updateCoins(collected: number, total: number): void;
  destroy(): void;
}

export class Hud implements IHUD {
  private scene: Scene;
  private scoreText!: Phaser.GameObjects.Text;
  private livesText!: Phaser.GameObjects.Text;
  private coinsText!: Phaser.GameObjects.Text;

  constructor(scene: Scene, score: number, lives: number, totalCoins: number) {
    this.scene = scene;
    this.init(score, lives, totalCoins);
  }

  private init(score: number, lives: number, totalCoins: number) {
    this.scoreText = this.scene.add.text(16, 16, `Puntuaci√≥n: ${score}`, {
      fontSize: '32px',
      color: '#000'
    });

    this.livesText = this.scene.add.text(16, 60, `Vidas: ${lives}`, {
      fontSize: '32px',
      color: '#000'
    });

    this.coinsText = this.scene.add.text(16, 104, `Monedas: 0/${totalCoins}`, {
      fontSize: '32px',
      color: '#000'
    });
  }

  updateScore(score: number): void {
    this.scoreText.setText(`Puntuaci√≥n: ${score}`);
  }

  updateLives(lives: number): void {
    this.livesText.setText(`Vidas: ${lives}`);
  }

  updateCoins(collected: number, total: number): void {
    this.coinsText.setText(`Monedas: ${collected}/${total}`);
  }

  destroy(): void {
    this.scoreText?.destroy();
    this.livesText?.destroy();
    this.coinsText?.destroy();
  }
}
</file>

<file path="src/game/utils/PlatformUtils.ts">
export function getTopYForX(platforms: Phaser.Physics.Arcade.StaticGroup, x: number, fallback = 420): number {
  let y = fallback;
  const children = platforms.getChildren() as any[];
  children.forEach((obj: any) => {
    if (!obj || typeof obj.x !== 'number' || typeof obj.y !== 'number') return;
    const w = (obj.displayWidth ?? 100);
    const h = (obj.displayHeight ?? 20);
    const halfW = w / 2;
    if (x >= obj.x - halfW && x <= obj.x + halfW) {
      const top = obj.y - h / 2;
      if (top < y) y = top;
    }
  });
  return y;
}
</file>

<file path="src/main.ts">
import App from './App.vue';
import { createApp } from 'vue';

createApp(App).mount('#app');
</file>

<file path="src/PhaserGame.vue">
<script setup lang="ts">
import { onMounted, onUnmounted, ref } from 'vue';
import { EventBus } from './game/EventBus';
import StartGame from './game/main';
import Phaser from 'phaser';

// Typed references to current Phaser instances
const scene = ref<Phaser.Scene | null>(null);
const game = ref<Phaser.Game | null>(null);

const emit = defineEmits<{
  (e: 'current-active-scene', scene: Phaser.Scene): void
}>();

onMounted(() => {
  game.value = StartGame('game-container');

  EventBus.on('current-scene-ready', (sceneInstance: Phaser.Scene) => {
    emit('current-active-scene', sceneInstance);
    scene.value = sceneInstance;
  });
});

onUnmounted(() => {
  if (game.value) {
    game.value.destroy(true);
    game.value = null;
  }
});

// Expose raw values (not Refs) for parent consumers
defineExpose({
  get scene() {
    return scene.value;
  },
  get game() {
    return game.value;
  }
});

</script>

<template>
    <div id="game-container"></div>
</template>
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2020",
        "useDefineForClassFields": true,
        "module": "ESNext",
        "lib": [
            "ES2020",
            "DOM",
            "DOM.Iterable"
        ],
        "skipLibCheck": true,
        /* Bundler mode */
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,
        "jsx": "preserve",
        /* Linting */
        "strict": true,
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "noFallthroughCasesInSwitch": true,
        "strictPropertyInitialization": false
    },
    "include": [
        "src/**/*.ts",
        "src/**/*.tsx",
        "src/**/*.vue"
    ],
    "references": [
        {
            "path": "./tsconfig.node.json"
        }
    ]
}
</file>

<file path="tsconfig.node.json">
{
    "compilerOptions": {
        "composite": true,
        "skipLibCheck": true,
        "module": "ESNext",
        "moduleResolution": "bundler",
        "allowSyntheticDefaultImports": true,
        "strict": true
    },
    "include": [
        "vite.config.ts"
    ]
}
</file>

<file path="vite/config.dev.mjs">
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
    base: './',
    plugins: [
        vue(),
    ],
    resolve: {
        alias: {
            '@': fileURLToPath(new URL('../src', import.meta.url))
        }
    },
    server: {
        port: 8080
    }
})
</file>

<file path="vite/config.prod.mjs">
import { fileURLToPath, URL } from 'node:url'
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue'

const phasermsg = () => {
    return {
        name: 'phasermsg',
        buildStart() {
            process.stdout.write(`Building for production...\n`);
        },
        buildEnd() {
            const line = "---------------------------------------------------------";
            const msg = `‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è Tell us about your game! - games@phaser.io ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è`;
            process.stdout.write(`${line}\n${msg}\n${line}\n`);

            process.stdout.write(`‚ú® Done ‚ú®\n`);
        }
    }
}

export default defineConfig({
    base: './',
    plugins: [
        vue(),
        phasermsg()
    ],
    resolve: {
        alias: {
          '@': fileURLToPath(new URL('../src', import.meta.url))
        }
      },
    logLevel: 'warning',
    build: {
        rollupOptions: {
            output: {
                manualChunks: {
                    phaser: ['phaser']
                }
            }
        },
        minify: 'terser',
        terserOptions: {
            compress: {
                passes: 2
            },
            mangle: true,
            format: {
                comments: false
            }
        }
    }
});
</file>

</files>
